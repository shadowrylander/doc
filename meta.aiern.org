#+setupfile: README.org

The tangle functions are adapted from [[https://emacs.stackexchange.com/a/29884/31428][this answer on the emacs Stack Exchange]],
which was written by [[https://emacs.stackexchange.com/users/2710/andrew-swann][Andrew Swann]].

* wtt-pre

#+call: hash() :exports none

#+RESULTS:
: 20210821132334835661400

#+name: 20210821132334835661400
#+begin_src emacs-lisp
(load (concat (getenv "HOME") "/.emacs.d/early-init.el"))
(meq/up markdown-mode :mode ("\\.md\\'")
    :use-package-postconfig (yasnippet)
    :upnsd-preconfig (titan :custom (meq/var/titan-snippets-dir (meq/ued-siluam "titan" "snippets"))))
#+end_src

* wtt-post

#+call: hash() :exports none

#+RESULTS:
: 20210821140509092087900

#+name: 20210821140509092087900
#+begin_src emacs-lisp
(meq/insert-snippet "markdown titan template")
(save-buffer)
#+end_src

* wtt.sh

#+call: hash() :exports none

#+RESULTS:
: 20210601225227507463400

#+name: 20210601225227507463400
#+begin_src emacs-lisp :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
":"; exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-
(princ (format-time-string "%Y%m%d%H%M%S%N")) (terpri)
#+end_src

* wtt.fell.sh

#+call: hash() :exports none

#+RESULTS:
: 20210820041859058805800

#+name: 20210820041859058805800
#+begin_src emacs-lisp :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
":"; exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-
<<20210821132334835661400>>
(meq/upnsd fell
    :custom (meq/var/fell-snippets-dir (meq/ued-siluam "fell" "snippets"))
    :mode ("\\.fell\\.md\\'" . fell-markdown-mode))
(find-file (concat (meq/timestamp) ".fell.md"))
<<20210821140509092087900>>
#+end_src

* wtt.doc.sh

#+call: hash() :exports none

#+RESULTS:
: 20210820041900953120200

#+name: 20210820041900953120200
#+begin_src emacs-lisp :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
":"; exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-
<<20210821132334835661400>>
(meq/upnsd doc
    :custom (meq/var/doc-snippets-dir (meq/ued-siluam "doc" "snippets"))
    :mode ("\\.doc\\.md\\'" . doc-markdown-mode))
(find-file (concat (meq/timestamp) ".doc.md"))
<<20210821140509092087900>>
#+end_src

* vterm-start.sh

#+call: hash() :exports none

#+RESULTS:
: 20210710215312854336800

#+name: 20210710215312854336800
#+begin_src sh :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
tmux new -As0
#+end_src

* org-tangle.sh

Adapted from: https://github.com/hlissner/doom-emacs/blob/develop/bin/org-tangle

#+call: hash() :exports none

#+RESULTS:
: 20210601225359807196100

#+name: 20210601225359807196100
#+begin_src emacs-lisp :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
":"; exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-

(setq org-confirm-babel-evaluate nil)

(require 'cl-lib)
(require 'ox)
(require 'ob-tangle)

<<20210601225401786848500>>

(defun usage ()
  (with-temp-buffer
    (insert (format "%s %s [OPTIONS] [TARGETS...]\n"
                    "[1mUsage:[0m"
                    (file-name-nondirectory load-file-name))
            "\n"
            "A command line interface for tangling org-mode files. TARGETS can be\n"
            "files or folders (which are searched for org files recursively).\n"
            "\n"
            "This is useful for literate configs that rely on command line\n"
            "workflows to build it.\n"
            "\n"
            "[1mExample:[0m\n"
            "  org-tangle some-file.org\n"
            "  org-tangle literate/config/\n"
            "  org-tangle -p -l sh scripts.org > do_something.sh\n"
            "  org-tangle -p -l python -t tagA -t tagB file.org | python\n"
            "\n"
            "[1mOptions:[0m\n"
            "  -a --all\t\tTangle all blocks by default\n"
            "  -l --lang LANG\tOnly tangle blocks written in LANG\n"
            "  -p --print\t\tPrint tangled output to stdout than to files\n"
            "  -t --tag TAG\n"
            "     --and TAG\n"
            "     --or TAG\n"
            "    Lets you tangle org blocks by tag. You may have more than one\n"
            "    of these options.\n")
    (princ (buffer-string))))

(defun *org-babel-tangle (orig-fn &rest args)
  "Don't write tangled blocks to files, print them to stdout."
  (cl-letf (((symbol-function 'write-region)
             (lambda (start end filename &optional append visit lockname mustbenew)
               (princ (buffer-string)))))
    (apply orig-fn args)))

(defun *org-babel-tangle-collect-blocks (&optional language tangle-file)
  "Like `org-babel-tangle-collect-blocks', but will ignore blocks that are in
trees with the :notangle: tag."
  (let ((counter 0) last-heading-pos blocks)
    (org-babel-map-src-blocks (buffer-file-name)
      (let ((current-heading-pos
             (org-with-wide-buffer
              (org-with-limited-levels (outline-previous-heading)))))
        (if (eq last-heading-pos current-heading-pos) (cl-incf counter)
          (setq counter 1)
          (setq last-heading-pos current-heading-pos)))
      (unless (org-in-commented-heading-p)
        (require 'org)
        (let* ((tags (org-get-tags-at))
               (info (org-babel-get-src-block-info 'light))
               (src-lang (nth 0 info))
               (src-tfile (cdr (assq :tangle (nth 2 info)))))
          (cond ((member "notangle" tags))

                ((and (or or-tags and-tags)
                      (or (not and-tags)
                          (let ((a (cl-intersection and-tags tags :test #'string=))
                                (b and-tags))
                            (not (or (cl-set-difference a b :test #'equal)
                                     (cl-set-difference b a :test #'equal)))))
                      (or (not or-tags)
                          (cl-intersection or-tags tags :test #'string=))
                      t))

                ((or (not (or all-blocks src-tfile))
                     (string= src-tfile "no")  ; tangle blocks by default
                     (and tangle-file (not (equal tangle-file src-tfile)))
                     (and language (not (string= language src-lang)))))

                ;; Add the spec for this block to blocks under its language.
                ((let ((by-lang (assoc src-lang blocks))
                       (block (org-babel-tangle-single-block counter)))
                   (if by-lang
                       (setcdr by-lang (cons block (cdr by-lang)))
                     (push (cons src-lang (list block)) blocks))))))))
    ;; Ensure blocks are in the correct order.
    (mapcar (lambda (b) (cons (car b) (nreverse (cdr b)))) blocks)))
(advice-add #'org-babel-tangle-collect-blocks :override #'*org-babel-tangle-collect-blocks)

(defvar all-blocks nil)
(defvar and-tags nil)
(defvar or-tags nil)
(let (lang srcs and-tags or-tags)
  (pop argv)
  (while argv
    (let ((arg (pop argv)))
      (pcase arg
        ((or "-h" "--help")
         (usage)
         (error ""))
        ((or "-a" "--all")
         (setq all-blocks t))
        ((or "-l" "--lang")
         (setq lang (pop argv)))
        ((or "-p" "--print")
         (advice-add #'org-babel-tangle :around #'*org-babel-tangle))
        ((or "-t" "--tag" "--and")
         (push (pop argv) and-tags))
        ("--or"
         (push (pop argv) or-tags))
        ((guard (string-match-p "^--lang=" arg))
         (setq lang (cadr (split-string arg "=" t t))))
        ((guard (file-directory-p arg))
         (setq srcs
               (append (directory-files-recursively arg "\\.org$")
                       srcs)))
        ((guard (file-exists-p arg))
         (push arg srcs))
        (_ (error "Unknown option or file: %s" arg)))))

  (dolist (file srcs)
    (message (format "\n\nNow tangling %s:\n" file))
    (let ((backup (make-temp-file (file-name-base file) nil ".backup.org")))
      (unwind-protect
          ;; Prevent slow hooks from interfering
          (let (org-mode-hook)
            ;; We do the ol' switcheroo because `org-babel-tangle' writes
            ;; changes to the current file, which would be imposing on the user.
            (copy-file file backup t)
            (with-current-buffer (find-file-noselect file)

              ;; Tangling doesn't expand #+INCLUDE directives, so we do it
              ;; ourselves, since includes are so useful for literate configs!
              ;; (org-export-expand-include-keyword)

              (org-babel-tangle nil nil lang)))
        (ignore-errors (copy-file backup file t))
        (ignore-errors (delete-file backup)))))
  (kill-emacs 0))
#+end_src

* org-tangle-functions.el

#+call: hash() :exports none

#+RESULTS:
: 20210601225401786848500

#+name: 20210601225401786848500
#+begin_src emacs-lisp :tangle (meq/tangle-path)
(when (file-exists-p "~/.emacs.d/README.org")
    (org-babel-lob-ingest "~/.emacs.d/README.org"))
(when (file-exists-p "~/.emacs.d/strange.aiern.org")
    (org-babel-lob-ingest "~/.emacs.d/strange.aiern.org"))

(defun meq/get-header nil (interactive)
    (nth 4 (org-heading-components)))
(defun meq/tangle-path nil (interactive)
    (string-remove-prefix "/" (concat
        (org-format-outline-path (org-get-outline-path)) "/"
            (meq/get-header))))
(defun meq/get-theme-from-header nil (interactive)
    (string-remove-suffix "-theme.el" (meq/get-header)))
#+end_src

* git-subtree

#+begin_src bash :tangle (meq/tangle-path) :shebang "#!/usr/bin/env bash"
#
# git-subtree.sh: split/join git repositories in subdirectories of this one
#
# Copyright (C) 2009 Avery Pennarun <apenwarr@gmail.com>
#
if [ $# -eq 0 ]; then
    set -- -h
fi
OPTS_SPEC="\
git subtree add   --prefix=<prefix> <repository> <refspec>
git subtree merge --prefix=<prefix> <commit>
git subtree pull  --prefix=<prefix> [<repository> [<refspec>...]]
git subtree pull-all
git subtree push-all
git subtree push  --prefix=<prefix> [<repository> [<refspec>...]]
git subtree list
git subtree split --prefix=<prefix> <commit...>
git subtree from-submodule --prefix=<prefix>
git subtree prune
git subtree diff  --prefix=<prefix> [<repository> [<refspec>...]]
--
h,help        show the help
q             quiet
d             show debug messages
P,prefix=     the name of the subdir to split out
m,message=    use the given message as the commit message for the merge commit
 options for 'split'
annotate=     add a prefix to commit message of new commits
b,branch=     create a new branch from the split subtree
ignore-joins  ignore prior --rejoin commits
onto=         try connecting new tree to an existing one
rejoin        merge the new branch back into HEAD
 options for 'push'
f,force       use force push
 options for 'add', 'merge', 'pull' and 'push'
squash        merge subtree changes as a single commit
"
eval "$(echo "$OPTS_SPEC" | git rev-parse --parseopt -- "$@" || echo exit $?)"

PATH=$PATH:$(git --exec-path)
. git-sh-setup

require_work_tree

quiet=
branch=
debug=
command=
onto=
rejoin=
ignore_joins=
annotate=
squash=
message=

debug()
{
        if [ -n "$debug" ]; then
                echo "$@" >&2
        fi
}

say()
{
        if [ -z "$quiet" ]; then
                echo "$@" >&2
        fi
}

assert()
{
        if "$@"; then
                :
        else
                die "assertion failed: " "$@"
        fi
}


#echo "Options: $*"

while [ $# -gt 0 ]; do
        opt="$1"
        shift
        case "$opt" in
                -q) quiet=1 ;;
                -d) debug=1 ;;
                --annotate) annotate="$1"; shift ;;
                --no-annotate) annotate= ;;
                -b) branch="$1"; shift ;;
                -P|--prefix) prefix="$1"; shift ;;
                -m) message="$1"; shift ;;
                -f|--force) force=1 ;;
                --no-prefix) prefix= ;;
                --onto) onto="$1"; shift ;;
                --no-onto) onto= ;;
                --rejoin) rejoin=1 ;;
                --no-rejoin) rejoin= ;;
                --ignore-joins) ignore_joins=1 ;;
                --no-ignore-joins) ignore_joins= ;;
                --squash) squash=1 ;;
                --no-squash) squash= ;;
                --) break ;;
                *) die "Unexpected option: $opt" ;;
        esac
done

# Remove trailing slash
prefix="${prefix%/}";

command="$1"
shift
case "$command" in
        add|merge|pull|pull-all|push-all|from-submodule|prune) default= ;;
        split|push|diff|list) default="--default HEAD" ;;
        *) die "Unknown command '$command'" ;;
esac

if [ -z "$prefix" -a "$command" != "pull-all" -a "$command" != "push-all" -a "$command" != "list" -a "$command" != "prune" ]; then
        die "You must provide the --prefix option."
fi

case "$command" in
        pull-all);;
        push-all);;
        list);;
        prune);;
        add) [ -e "$prefix" ] && 
                die "prefix '$prefix' already exists." ;;
        *)   [ -e "$prefix" ] || 
                die "'$prefix' does not exist; use 'git subtree add'" ;;
esac

dir="$(dirname "$prefix/.")"

if [ "$command" != "pull" -a "$command" != "add" -a "$command" != "push" -a "$command" != "pull-all" -a "$command" != "diff" ]; then
        revs=$(git rev-parse $default --revs-only "$@") || exit $?
        dirs="$(git rev-parse --no-revs --no-flags "$@")" || exit $?
        if [ -n "$dirs" ]; then
                die "Error: Use --prefix instead of bare filenames."
        fi
fi

debug "command: {$command}"
debug "quiet: {$quiet}"
debug "revs: {$revs}"
debug "dir: {$dir}"
debug "opts: {$*}"
debug

cache_setup()
{
        cachedir="$GIT_DIR/subtree-cache/$$"
        rm -rf "$cachedir" || die "Can't delete old cachedir: $cachedir"
        mkdir -p "$cachedir" || die "Can't create new cachedir: $cachedir"
        mkdir -p "$cachedir/notree" || die "Can't create new cachedir: $cachedir/notree"
        debug "Using cachedir: $cachedir" >&2
}

cache_get()
{
        for oldrev in $*; do
                if [ -r "$cachedir/$oldrev" ]; then
                        read newrev <"$cachedir/$oldrev"
                        echo $newrev
                fi
        done
}

cache_miss()
{
        for oldrev in $*; do
                if [ ! -r "$cachedir/$oldrev" ]; then
                        echo $oldrev
                fi
        done
}

check_parents()
{
        missed=$(cache_miss $*)
        for miss in $missed; do
                if [ ! -r "$cachedir/notree/$miss" ]; then
                        debug "  incorrect order: $miss"
                fi
        done
}

set_notree()
{
        echo "1" > "$cachedir/notree/$1"
}

cache_set()
{
        oldrev="$1"
        newrev="$2"
        if [ "$oldrev" != "latest_old" \
             -a "$oldrev" != "latest_new" \
             -a -e "$cachedir/$oldrev" ]; then
                die "cache for $oldrev already exists!"
        fi
        echo "$newrev" >"$cachedir/$oldrev"
}

rev_exists()
{
        if git rev-parse "$1" >/dev/null 2>&1; then
                return 0
        else
                return 1
        fi
}

rev_is_descendant_of_branch()
{
        newrev="$1"
        branch="$2"
        branch_hash=$(git rev-parse $branch)
        match=$(git rev-list -1 $branch_hash ^$newrev)

        if [ -z "$match" ]; then
                return 0
        else
                return 1
        fi
}

# if a commit doesn't have a parent, this might not work.  But we only want
# to remove the parent from the rev-list, and since it doesn't exist, it won't
# be there anyway, so do nothing in that case.
try_remove_previous()
{
        if rev_exists "$1^"; then
                echo "^$1^"
        fi
}

find_latest_squash()
{
        debug "Looking for latest squash ($dir)..."
        dir="$1"
        sq=
        main=
        sub=
        git log --grep="^git-subtree-dir: $dir/*\$" \
                --pretty=format:'START %H%n%s%n%n%b%nEND%n' HEAD |
        while read a b junk; do
                debug "$a $b $junk"
                debug "{{$sq/$main/$sub}}"
                case "$a" in
                        START) sq="$b" ;;
                        git-subtree-mainline:) main="$b" ;;
                        git-subtree-split:) sub="$b" ;;
                        END)
                                if [ -n "$sub" ]; then
                                        if [ -n "$main" ]; then
                                                # a rejoin commit?
                                                # Pretend its sub was a squash.
                                                sq="$sub"
                                        fi
                                        debug "Squash found: $sq $sub"
                                        echo "$sq" "$sub"
                                        break
                                fi
                                sq=
                                main=
                                sub=
                                ;;
                esac
        done
}

find_existing_splits()
{
        debug "Looking for prior splits..."
        dir="$1"
        revs="$2"
        main=
        sub=
        git log --grep="^git-subtree-dir: $dir/*\$" \
                --pretty=format:'START %H%n%s%n%n%b%nEND%n' $revs |
        while read a b junk; do
                case "$a" in
                        START) sq="$b" ;;
                        git-subtree-mainline:) main="$b" ;;
                        git-subtree-split:) sub="$b" ;;
                        END)
                                debug "  Main is: '$main'"
                                if [ -z "$main" -a -n "$sub" ]; then
                                        # squash commits refer to a subtree
                                        debug "  Squash: $sq from $sub"
                                        cache_set "$sq" "$sub"
                                fi
                                if [ -n "$main" -a -n "$sub" ]; then
                                        debug "  Prior: $main -> $sub"
                                        cache_set $main $sub
                                        cache_set $sub $sub
                                        try_remove_previous "$main"
                                        try_remove_previous "$sub"
                                fi
                                main=
                                sub=
                                ;;
                esac
        done
}

copy_commit()
{
        # We're going to set some environment vars here, so
        # do it in a subshell to get rid of them safely later
        debug copy_commit "{$1}" "{$2}" "{$3}"
        git log -1 --pretty=format:'%an%n%ae%n%ad%n%cn%n%ce%n%cd%n%s%n%n%b' "$1" |
        (
                read GIT_AUTHOR_NAME
                read GIT_AUTHOR_EMAIL
                read GIT_AUTHOR_DATE
                read GIT_COMMITTER_NAME
                read GIT_COMMITTER_EMAIL
                read GIT_COMMITTER_DATE
                export  GIT_AUTHOR_NAME \
                        GIT_AUTHOR_EMAIL \
                        GIT_AUTHOR_DATE \
                        GIT_COMMITTER_NAME \
                        GIT_COMMITTER_EMAIL \
                        GIT_COMMITTER_DATE
                (echo -n "$annotate"; cat ) |
                git commit-tree "$2" $3  # reads the rest of stdin
        ) || die "Can't copy commit $1"
}

add_msg()
{
        dir="$1"
        latest_old="$2"
        latest_new="$3"
        if [ -n "$message" ]; then
                commit_message="$message"
        else
                commit_message="Add '$dir/' from commit '$latest_new'"
        fi
        cat <<-EOF
				$commit_message

				git-subtree-dir: $dir
				git-subtree-mainline: $latest_old
				git-subtree-split: $latest_new
		EOF
}

add_squashed_msg()
{
        if [ -n "$message" ]; then
                echo "$message"
        else
                echo "Merge commit '$1' as '$2'"
        fi
}

rejoin_msg()
{
        dir="$1"
        latest_old="$2"
        latest_new="$3"
        if [ -n "$message" ]; then
                commit_message="$message"
        else
                commit_message="Split '$dir/' into commit '$latest_new'"
        fi
        cat <<-EOF
                $commit_message
                
                git-subtree-dir: $dir
                git-subtree-mainline: $latest_old
                git-subtree-split: $latest_new
		EOF
}

squash_msg()
{
        dir="$1"
        oldsub="$2"
        newsub="$3"
        newsub_short=$(git rev-parse --short "$newsub")
        
        if [ -n "$oldsub" ]; then
                oldsub_short=$(git rev-parse --short "$oldsub")
                echo "Squashed '$dir/' changes from $oldsub_short..$newsub_short"
                echo
                git log --pretty=tformat:'%h %s' "$oldsub..$newsub"
                git log --pretty=tformat:'REVERT: %h %s' "$newsub..$oldsub"
        else
                echo "Squashed '$dir/' content from commit $newsub_short"
        fi
        
        echo
        echo "git-subtree-dir: $dir"
        echo "git-subtree-split: $newsub"
}

toptree_for_commit()
{
        commit="$1"
        git log -1 --pretty=format:'%T' "$commit" -- || exit $?
}

subtree_for_commit()
{
        commit="$1"
        dir="$2"
        git ls-tree "$commit" -- "$dir" |
        while read mode type tree name; do
                assert [ "$name" = "$dir" ]
                assert [ "$type" = "tree" -o "$type" = "commit" ]
                [ "$type" = "commit" ] && continue  # ignore submodules
                echo $tree
                break
        done
}

tree_changed()
{
        tree=$1
        shift
        if [ $# -ne 1 ]; then
                return 0   # weird parents, consider it changed
        else
                ptree=$(toptree_for_commit $1)
                if [ "$ptree" != "$tree" ]; then
                        return 0   # changed
                else
                        return 1   # not changed
                fi
        fi
}

new_squash_commit()
{
        old="$1"
        oldsub="$2"
        newsub="$3"
        tree=$(toptree_for_commit $newsub) || exit $?
        if [ -n "$old" ]; then
                squash_msg "$dir" "$oldsub" "$newsub" | 
                        git commit-tree "$tree" -p "$old" || exit $?
        else
                squash_msg "$dir" "" "$newsub" |
                        git commit-tree "$tree" || exit $?
        fi
}

copy_or_skip()
{
        rev="$1"
        tree="$2"
        newparents="$3"
        assert [ -n "$tree" ]

        identical=
        nonidentical=
        p=
        gotparents=
        for parent in $newparents; do
                ptree=$(toptree_for_commit $parent) || exit $?
                [ -z "$ptree" ] && continue
                if [ "$ptree" = "$tree" ]; then
                        # an identical parent could be used in place of this rev.
                        identical="$parent"
                else
                        nonidentical="$parent"
                fi
                
                # sometimes both old parents map to the same newparent;
                # eliminate duplicates
                is_new=1
                for gp in $gotparents; do
                        if [ "$gp" = "$parent" ]; then
                                is_new=
                                break
                        fi
                done
                if [ -n "$is_new" ]; then
                        gotparents="$gotparents $parent"
                        p="$p -p $parent"
                fi
        done
        
        if [ -n "$identical" ]; then
                echo $identical
        else
                copy_commit $rev $tree "$p" || exit $?
        fi
}

ensure_clean()
{
        if ! git diff-index HEAD --exit-code --quiet 2>&1; then
                die "Working tree has modifications.  Cannot add."
        fi
        if ! git diff-index --cached HEAD --exit-code --quiet 2>&1; then
                die "Index has modifications.  Cannot add."
        fi
}

cmd_add()
{
        if [ -e "$dir" ]; then
                die "'$dir' already exists.  Cannot add."
        fi

        ensure_clean
        
        if [ $# -eq 1 ]; then
                "cmd_add_commit" "$@"
        elif [ $# -eq 2 ]; then
                "cmd_add_repository" "$@"
        else
            say "error: parameters were '$@'"
            die "Provide either a refspec or a repository and refspec."
        fi
}

cmd_add_repository()
{
        echo "git fetch" "$@"
        repository=$1
        refspec=$2
        git fetch "$@" || exit $?
        revs=FETCH_HEAD
        set -- $revs
        cmd_add_commit "$@"

        # now add it to our list of repos
        git config -f .gittrees --unset subtree.$dir.url
        git config -f .gittrees --add subtree.$dir.url $repository
        git config -f .gittrees --unset subtree.$dir.path
        git config -f .gittrees --add subtree.$dir.path $dir
        git config -f .gittrees --unset subtree.$dir.branch
        git config -f .gittrees --add subtree.$dir.branch $refspec
}

cmd_add_commit()
{
        revs=$(git rev-parse $default --revs-only "$@") || exit $?
        set -- $revs
        rev="$1"
        
        debug "Adding $dir as '$rev'..."
        git read-tree --prefix="$dir" $rev || exit $?
        git checkout -- "$dir" || exit $?
        tree=$(git write-tree) || exit $?
        
        headrev=$(git rev-parse HEAD) || exit $?
        if [ -n "$headrev" -a "$headrev" != "$rev" ]; then
                headp="-p $headrev"
        else
                headp=
        fi
        
        if [ -n "$squash" ]; then
                rev=$(new_squash_commit "" "" "$rev") || exit $?
                commit=$(add_squashed_msg "$rev" "$dir" |
                         git commit-tree $tree $headp -p "$rev") || exit $?
        else
                commit=$(add_msg "$dir" "$headrev" "$rev" |
                         git commit-tree $tree $headp -p "$rev") || exit $?
        fi
        git reset "$commit" || exit $?
        
        say "Added dir '$dir'"
}

cmd_split()
{
        debug "Splitting $dir..."
        cache_setup || exit $?
        
        if [ -n "$onto" ]; then
                debug "Reading history for --onto=$onto..."
                git rev-list $onto |
                while read rev; do
                        # the 'onto' history is already just the subdir, so
                        # any parent we find there can be used verbatim
                        debug "  cache: $rev"
                        cache_set $rev $rev
                done
        fi
        
        if [ -n "$ignore_joins" ]; then
                unrevs=
        else
                unrevs="$(find_existing_splits "$dir" "$revs")"
        fi
        
        # We can't restrict rev-list to only $dir here, because some of our
        # parents have the $dir contents the root, and those won't match.
        # (and rev-list --follow doesn't seem to solve this)
        grl='git rev-list --topo-order --reverse --parents $revs $unrevs'
        revmax=$(eval "$grl" | wc -l)
        revcount=0
        createcount=0
        eval "$grl" |
        while read rev parents; do
                revcount=$(($revcount + 1))
                say -n "$revcount/$revmax ($createcount)
"
                debug "Processing commit: $rev"
                exists=$(cache_get $rev)
                if [ -n "$exists" ]; then
                        debug "  prior: $exists"
                        continue
                fi
                createcount=$(($createcount + 1))
                debug "  parents: $parents"
                newparents=$(cache_get $parents)
                debug "  newparents: $newparents"
                
                tree=$(subtree_for_commit $rev "$dir")
                debug "  tree is: $tree"

                check_parents $parents
                
                # ugly.  is there no better way to tell if this is a subtree
                # vs. a mainline commit?  Does it matter?
                if [ -z $tree ]; then
                        set_notree $rev
                        if [ -n "$newparents" ]; then
                                cache_set $rev $rev
                        fi
                        continue
                fi

                newrev=$(copy_or_skip "$rev" "$tree" "$newparents") || exit $?
                debug "  newrev is: $newrev"
                cache_set $rev $newrev
                cache_set latest_new $newrev
                cache_set latest_old $rev
        done || exit $?
        latest_new=$(cache_get latest_new)
        if [ -z "$latest_new" ]; then
                die "No new revisions were found"
        fi
        
        if [ -n "$rejoin" ]; then
                debug "Merging split branch into HEAD..."
                latest_old=$(cache_get latest_old)
                git merge -s ours \
                        -m "$(rejoin_msg $dir $latest_old $latest_new)" \
                        $latest_new >&2 || exit $?
        fi
        if [ -n "$branch" ]; then
                if rev_exists "refs/heads/$branch"; then
                        if ! rev_is_descendant_of_branch $latest_new $branch; then
                                die "Branch '$branch' is not an ancestor of commit '$latest_new'."
                        fi
                        action='Updated'
                else
                        action='Created'
                fi
                git update-ref -m 'subtree split' "refs/heads/$branch" $latest_new || exit $?
                say "$action branch '$branch'"
        fi
        echo $latest_new
        exit 0
}

cmd_merge()
{
        revs=$(git rev-parse $default --revs-only "$@") || exit $?
        ensure_clean
        
        set -- $revs
        if [ $# -ne 1 ]; then
                die "You must provide exactly one revision.  Got: '$revs'"
        fi
        rev="$1"
        
        if [ -n "$squash" ]; then
                first_split="$(find_latest_squash "$dir")"
                if [ -z "$first_split" ]; then
                        die "Can't squash-merge: '$dir' was never added."
                fi
                set $first_split
                old=$1
                sub=$2
                if [ "$sub" = "$rev" ]; then
                        say "Subtree is already at commit $rev."
                        exit 0
                fi
                new=$(new_squash_commit "$old" "$sub" "$rev") || exit $?
                debug "New squash commit: $new"
                rev="$new"
        fi

        version=$(git version)
        if [ "$version" \< "git version 1.7" ]; then
                if [ -n "$message" ]; then
                        git merge -s subtree --message="$message" $rev
                else
                        git merge -s subtree $rev
                fi
        else
                if [ -n "$message" ]; then
                        git merge -Xsubtree="$prefix" --message="$message" $rev
                else
                        git merge -Xsubtree="$prefix" $rev
                fi
        fi
}

cmd_pull()
{
        if [ $# -gt 2 ]; then
                die "You should provide either <refspec> or <repository> <refspec>"
        fi
        if [ -e "$dir" ]; then
                ensure_clean
                if [ $# -eq 1 ]; then
                        repository=$(git config -f .gittrees subtree.$prefix.url)
                        refspec=$1
                elif [ $# -eq 2 ]; then
                        repository=$1
                        refspec=$2
                else
                        repository=$(git config -f .gittrees subtree.$prefix.url)
                        refspec=$(git config -f .gittrees subtree.$prefix.branch)
                fi
                git fetch $repository $refspec || exit $?
                echo "git fetch using: " $repository $refspec
                revs=FETCH_HEAD
                set -- $revs
                cmd_merge "$@"
        else
                die "'$dir' must already exist. Try 'git subtree add'."
        fi
}

cmd_diff()
{
        if [ -e "$dir" ]; then
                if [ $# -eq 1 ]; then
                        repository=$(git config -f .gittrees subtree.$prefix.url)
                        refspec=$1
                elif [ $# -eq 2 ]; then
                        repository=$1
                        refspec=$2
                else
                        repository=$(git config -f .gittrees subtree.$prefix.url)
                        refspec=$(git config -f .gittrees subtree.$prefix.branch)
                fi
                # this is ugly, but I don't know of a better way to do it. My git-fu is weak.
                # git diff-tree expects a treeish, but I have only a repository and branch name.
                # I don't know how to turn that into a treeish without creating a remote.
                # Please change this if you know a better way!
                tmp_remote=__diff-tmp
                git remote rm $tmp_remote > /dev/null 2>&1
                git remote add -t $refspec $tmp_remote $repository > /dev/null
                # we fetch as a separate step so we can pass -q (quiet), which isn't an option for "git remote"
                # could this instead be "git fetch -q $repository $refspec" and leave aside creating the remote?
                # Still need a treeish for the diff-tree command...
                git fetch -q $tmp_remote
                git diff-tree -p refs/remotes/$tmp_remote/$refspec
                git remote rm $tmp_remote > /dev/null 2>&1
        else
                die "Cannot resolve directory '$dir'. Please point to an existing subtree directory to diff. Try 'git subtree add' to add a subtree."
        fi
}
cmd_push()
{
        if [ $# -gt 2 ]; then
                die "You shold provide either <refspec> or <repository> <refspec>"
        fi
        if [ -e "$dir" ]; then
                if [ $# -eq 1 ]; then
                        repository=$(git config -f .gittrees subtree.$prefix.url)
                        refspec=$1
                elif [ $# -eq 2 ]; then
                        repository=$1
                        refspec=$2
                else
                        repository=$(git config -f .gittrees subtree.$prefix.url)
                        refspec=$(git config -f .gittrees subtree.$prefix.branch)
                fi

                push_opts=
                if [ "$force" == "1" ]; then
                  push_opts="$push_opts --force"
                fi

                echo "git push using: " $repository $refspec
                rev=$(git subtree split --prefix=$prefix)
                if [ -n "$rev" ]; then
                        git push $push_opts $repository $rev:refs/heads/$refspec
                else
                        die "Couldn't push, 'git subtree split' failed."
                fi
        else
            die "'$dir' must already exist. Try 'git subtree add'."
        fi
}

subtree_list()
{
        git config -f .gittrees -l | grep subtree | grep path | sed "s/.*=//g" |
        while read path; do
                repository=$(git config -f .gittrees subtree.$path.url)
                refspec=$(git config -f .gittrees subtree.$path.branch)
                echo "  $path           (merged from $repository branch $refspec) "
        done
}

cmd_list()
{
  subtree_list
}

cmd_from-submodule()
{
        ensure_clean

        local submodule_sha=$(git submodule status $prefix | cut -d ' ' -f 2)
        local submodule_orig_repo=$(git config --file .gitmodules submodule.$prefix.url)

        # Remove references to submodule.
        git config --remove-section submodule.$prefix
        git config --file .gitmodules --remove-section submodule.$prefix
        git add .gitmodules

        # Move submodule aside.
        local tmp_repo="$(mktemp -d /tmp/git-subtree.XXXXX)"
        rm -r $tmp_repo
        mv $prefix $tmp_repo
        git rm $prefix

        # Commit changes.
        git commit -m "Remove '$prefix/' submodule"

        # subtree add from submodule repo.
        # TODO: Could be determin HEAD to be a specific branch
        cmd_add_repository $tmp_repo HEAD

        # Update .gittrees with the original repo url
        git config --file .gittrees --unset subtree.$prefix.url
        git config --file .gittrees subtree.$prefix.url $submodule_orig_repo

        # Remove submodule repo.
        rm -rf $tmp_repo
}

cmd_prune()
{
        git config -f .gittrees -l | grep subtree | grep path | sed "s/.*=//g" |
        while read path; do
                if [ ! -e "$path" ]; then
                        echo "pruning $path"
                        git config -f .gittrees --remove-section subtree.$path
                fi
        done
}

cmd_pull-all()
{
        git config -f .gittrees -l | grep subtree | grep path | sed "s/.*=//g" |
        while read path; do
                git subtree pull -P $path $(git config -f .gittrees subtree.$path.url) $(git config -f .gittrees subtree.$path.branch) || exit $?
        done
}

cmd_push-all()
{
        git config -f .gittrees -l | grep subtree | grep path | sed "s/.*=//g" |
        while read path; do
                git subtree push -P $path $(git config -f .gittrees subtree.$path.url) $(git config -f .gittrees subtree.$path.branch) || exit $?
        done
}

"cmd_$command" "$@"
#+end_src

* .gitconfig

#+begin_src conf :tangle (meq/tangle-path)
[remote "aiern"]
    url = git@github.com:shadowrylander/aiern
    fetch = +refs/heads/*:refs/remotes/aiern/*
[remote "doom-aiern-modeline"]
    url = git@github.com:shadowrylander/doom-aiern-modeline
    fetch = +refs/heads/*:refs/remotes/doom-aiern-modeline/*
[remote "alloy"]
    url = git@github.com:shadowrylander/alloy.git
    fetch = +refs/heads/*:refs/remotes/alloy/*
[remote "alamode"]
    url = git@github.com:shadowrylander/alamode
    fetch = +refs/heads/*:refs/remotes/alamode/*
[remote "use-package-extras"]
    url = git@github.com:shadowrylander/use-package-extras
    fetch = +refs/heads/*:refs/remotes/use-package-extras/*
[remote "deino"]
    url = git@github.com:shadowrylander/deino
    fetch = +refs/heads/*:refs/remotes/deino/*
[remote "use-package-deino"]
    url = git@github.com:shadowrylander/use-package-deino
    fetch = +refs/heads/*:refs/remotes/use-package-deino/*
[remote "sorrow"]
    url = git@github.com:shadowrylander/sorrow
    fetch = +refs/heads/*:refs/remotes/sorrow/*
[remote "lode"]
    url = git@github.com:shadowrylander/lode
    fetch = +refs/heads/*:refs/remotes/lode/*
[remote "meq"]
    url = git@github.com:shadowrylander/meq.git
    fetch = +refs/heads/*:refs/remotes/meq/*
[remote "aiern-god-state"]
    url = git@github.com:shadowrylander/aiern-god-state
    fetch = +refs/heads/*:refs/remotes/aiern-god-state/*
[remote "janus"]
    url = git@github.com:shadowrylander/janus
    fetch = +refs/heads/*:refs/remotes/janus/*
[remote "titan"]
    url = git@github.com:shadowrylander/titan
    fetch = +refs/heads/*:refs/remotes/titan/*
[remote "fell"]
    url = git@github.com:shadowrylander/fell
    fetch = +refs/heads/*:refs/remotes/fell/*
[remote "doc"]
    url = git@github.com:shadowrylander/doc
    fetch = +refs/heads/*:refs/remotes/doc/*
[remote "cosmoem"]
    url = git@gitlab.com:shadowrylander/cosmoem
    fetch = +refs/heads/*:refs/remotes/cosmoem/*
[remote "cosmog"]
    url = git@github.com:shadowrylander/cosmog
    fetch = +refs/heads/*:refs/remotes/cosmog/*
[remote "prime"]
    url = git@github.com:shadowrylander/prime
    fetch = +refs/heads/*:refs/remotes/prime/*
[remote "uru"]
    url = git@github.com:shadowrylander/uru
    fetch = +refs/heads/*:refs/remotes/uru/*
[remote "meta"]
    url = git@github.com:shadowrylander/meta
    fetch = +refs/heads/*:refs/remotes/meta/*
[remote "riot"]
    url = git@github.com:shadowrylander/riot
    fetch = +refs/heads/*:refs/remotes/riot/*
[remote "evil-evilified-state"]
    url = git@github.com:shadowrylander/evil-evilified-state
    fetch = +refs/heads/*:refs/remotes/evil-evilified-state/*
[remote "helm-ido-like-guide"]
    url = git@github.com:shadowrylander/helm-ido-like-guide
    fetch = +refs/heads/*:refs/remotes/helm-ido-like-guide/*
#+end_src

* makefile

#+call: hash() :exports none

#+RESULTS:
: 20210622004216528168500

#+name: 20210622004216528168500
#+begin_src makefile :tangle (meq/tangle-path)
# Adapted From: https://www.systutorials.com/how-to-get-the-full-path-and-directory-of-a-makefile-itself/
.RECIPEPREFIX := |
.DEFAULT_GOAL := emacs

mkfilePath := $(abspath $(lastword $(MAKEFILE_LIST)))
mkfileDir := $(dir $(mkfilePath))
test := emacs --bg-daemon=test
killTest := emacsclient -s test -e "(kill-emacs)"

init:
|-sudo cp $(mkfileDir)/git-subtree $$(git --exec-path)/

subinit:
|git -C $(mkfileDir) submodule update --init --depth 1
|git -C $(mkfileDir) submodule sync
# |git -C $(mkfileDir) submodule foreach 'git -C $$toplevel config submodule.$$name.ignore all'
|cd $(mkfileDir)lib/org; make all; make autoloads

pull: init
|git -C $(mkfileDir) pull
|git -C $(mkfileDir) subtree pull-all

add:
|git submodule foreach git stash
|git -C $(mkfileDir) add .

commit:
|-git -C $(mkfileDir) commit --allow-empty-message -am ""

cammit: add commit

push-only: cammit
|-git -C $(mkfileDir) push

push: push-only init
|git -C $(mkfileDir) subtree prune
|-git -C $(mkfileDir) subtree push-all

tangle-setup:
|cp $(mkfileDir)/org-tangle.sh $(mkfileDir)/backup-tangle.sh
|chmod +x $(mkfileDir)/org-tangle.sh $(mkfileDir)/backup-tangle.sh

tangle: tangle-setup
|yes yes | fd . $(mkfileDir) \
    -HIe org \
    -E testing.aiern.org \
    -E resting.aiern.org \
    -E profiles \
    -E lib \
    -x $(mkfileDir)/backup-tangle.sh
|yes yes | fd . $(mkfileDir)/profiles/damascus \
    -HIe org \
    -E .local \
    -x $(mkfileDir)/backup-tangle.sh
|-$(mkfileDir)/backup-tangle.sh $(mkfileDir)/profiles/graphene/README.org
|-$(mkfileDir)/backup-tangle.sh $(mkfileDir)/profiles/nano/README.org
|fd . $(mkfileDir) \
    -HIe sh \
    -E .local \
    -x chmod +x

subtree-prep: tangle push-only

pre-test: subinit

test: pre-test
|emacs

test-doom: pre-test
|emacs --doom

test-graphene: pre-test
|emacs --graphene

test-nano: pre-test
|emacs --nano

pest: pre-test
|emacs -p

update-test: pre-test
|emacs --update

no-config-test:
|emacs -Q

test-and-kill-pre: pre-test
|-emacsclient -s test -e "(kill-emacs)"

test-and-kill: test-and-kill-pre
|$(test)
|$(killTest)

test-new-and-kill: test-and-kill-pre
|$(test) -Q
|$(killTest)

test-update-and-kill: test-and-kill-pre
|$(test) --update
|$(killTest)

test-update-doom-and-kill: test-and-kill-pre
|$(test) --udoom
|$(killTest)

test-update-graphene-and-kill: test-and-kill-pre
|$(test) --graphene --update
|$(killTest)

test-update-nano-and-kill: test-and-kill-pre
|$(test) --nano --update
|$(killTest)

delete-doom:
|rm -rf $(mkfileDir)/profiles/doom/.local

delete:
|rm -rf $(mkfileDir)/profiles/damascus/.local

delete-graphene:
|rm -rf $(mkfileDir)/profiles/graphene/.local

delete-nano:
|rm -rf $(mkfileDir)/profiles/nano/.local

emacs: tangle test
remacs: delete tangle test-update-and-kill test
doom-remacs: delete-doom tangle test-update-doom-and-kill test-doom
graphene-remacs: delete-graphene tangle test-update-graphene-and-kill test-graphene
nano-remacs: delete-nano tangle test-update-nano-and-kill test-nano
super-push: tangle push
super-push-only: tangle push-only
#+end_src

* lib
** damascus.el

#+call: hash() :exports none

#+RESULTS:
: 20210616175359970389700

#+name: 20210616175359970389700
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; damascus.el --- a simple package                     -*- lexical-binding: t; -*-

;; Copyright (C) 2021  Jeet Ray

;; Author: Jeet Ray <aiern@protonmail.com>
;; Keywords: lisp
;; Version: 0.0.1

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; Put a description of the package here

;;; Code:

;; code goes here

(provide 'damascus)
;;; damascus.el ends here
#+end_src

** meq-exwm-config.el

#+call: hash() :exports none

#+RESULTS:
: 20210821192734044989400

#+name: 20210821192734044989400
#+begin_src emacs-lisp :tangle (meq/tangle-path) :exports none
(meq/up exwm
    :init/defun* (post-exwm nil (interactive)
                    (unless (get-buffer "Alacritty") (meq/run "alacritty"))
                    (unless (get-buffer "obsidian") (meq/run "obsidian")))
    :hook (exwm-init . post-exwm)
    :use-package-preconfig (fringe :load-emacs-file-preconfig ("fringe")
                        :config
                            ;; (fringe-mode (quote (1 . 1)) nil (fringe))
                            ;; (fringe-mode '(3 . 0))
                            ;; (fringe-mode 'none)
                            ;; (fringe-mode 1)
                            )
    :use-package-postconfig (dmenu)
    :config
        (require 'scroll-bar)
        ;; Adapted From: https://github.com/ch11ng/exwm/blob/master/exwm-config.el#L34
        (require 'exwm-config)
        ;; Set the initial workspace number.
        (unless (get 'exwm-workspace-number 'saved-value)
            (setq exwm-workspace-number 4))
        ;; Make class name the buffer name
        (add-hook 'exwm-update-class-hook
                    (lambda ()
                    (exwm-workspace-rename-buffer exwm-class-name)))
        ;; Global keybindings.
        (unless (get 'exwm-input-global-keys 'saved-value)
            (setq exwm-input-global-keys
                `(
                    ;; 's-{p|`|z}': Enter the exwm-global deino
                    ([?\s-p] . uru)
                    ([?\s-`] . uru)
                    ([?\s-z] . uru)

                    (,(naked "s-tab") . next-buffer)
                    (,(naked "s-<iso-lefttab>") . previous-buffer)

                    ([?\s-q] . (lambda nil (interactive)
                        (unless meq/var/everything-else-initialized (meq/initialize-everything-else))
                        (deino-buffer/body)))

                    ;; 's-N': Switch to certain workspace.
                    ,@(mapcar (lambda (i)
                                `(,(kbd (format "s-%d" i)) .
                                (lambda ()
                                    (interactive)
                                    (exwm-workspace-switch-create ,i))))
                            (number-sequence 0 9)))))
        ;; Line-editing shortcuts
        (unless (get 'exwm-input-simulation-keys 'saved-value)
            (setq exwm-input-simulation-keys
                '(([?\C-b] . [left])
                    ([?\C-f] . [right])
                    ([?\C-p] . [up])
                    ([?\C-n] . [down])
                    ([?\C-a] . [home])
                    ([?\C-e] . [end])
                    ([?\M-v] . [prior])
                    ([?\C-v] . [next])
                    ([?\C-d] . [delete])
                    ([?\C-k] . [S-end delete]))))
        ;; Enable EXWM
        (exwm-enable)
        ;; Configure Ido
        (exwm-config-ido)
        ;; Other configurations
        (exwm-config-misc)

        ;; (exwm-config-default)
        ;; (exwm-enable)

    ;; Adapted From: https://www.reddit.com/r/emacs/comments/8yf6dx/key_chords_in_exwm/
    :gsetq (exwm-manage-force-tiling t)
        ;; (exwm-input-line-mode-passthrough t)

    :demon ((naked "XF86PowerOff") 'deino-exwm/body)
    :which-key-change-ryo ("e" "exwm")
    :deino (deino-exwm nil "e e"
                ("`" nil "cancel")
                ("XF86PowerOff" deino-exwm/power/body "power")
                ("s" deino-exwm/shells/body "shells"))
            (deino-exwm/power (:color blue) "e p"
                ("r" (meq/run "reboot") "reboot")
                ("q" (meq/run "poweroff") "poweroff")
                ("XF86PowerOff" (meq/run "systemctl suspend" "suspend") "suspend"))
            (deino-exwm/shells (:color blue) "e s"
                ("a" (meq/run "alacritty") "alacritty"))
    :uru (exwm-mode t deino-exwm-global (:color blue) "e g"
        ("`" nil "cancel")
        ("c" exwm-input-release-keyboard "char mode")
        ("l" exwm-input-grab-keyboard "line mode")
        ("r" exwm-reset "reset")
        ("w" exwm-workspace-switch "workspace switch")
        ("i" meq/run-interactive "run")
        ("b" deino-buffer/body "buffers")))
#+end_src

** meq-hydra-config.el

#+call: hash() :exports none

#+RESULTS:
: 20210821211206922820400

#+name: 20210821211206922820400
#+begin_src emacs-lisp :tangle (meq/tangle-path) :exports none
(meq/up hydra
    :custom (hydra-hint-display-type 'lv)
    :bind (:map hydra-base-map ("~" . hydra--universal-argument))
    :upnsd-preconfig (janus)
    :use-package-preconfig (use-package-hydra)
    :upnsd-postconfig (use-package-deino) (deino :custom (deino-hint-display-type 'lv)))
#+end_src

** meq-alloy-config.el

#+call: hash() :exports none

#+RESULTS:
: 20210821211654763595900

#+name: 20210821211654763595900
#+begin_src emacs-lisp :tangle (meq/tangle-path) :exports none
(meq/upnsd alloy
    :upnsd-postconfig (lode) (prime)
        (uru :config (prime "u u" uru "uru")
                    (prime "u m" minoru "minoru"))
    :use-package-preconfig (command-log-mode)
        ;; Important: https://github.com/noctuid/general.el/issues/53#issuecomment-307262154
        (use-package-chords)
    :config
        (alloy-auto-unbind-keys)
        (alloy-def :keymaps demon-run
            ;; Adapted From:
            ;; Answer: https://stackoverflow.com/a/4557027/10827766
            ;; User: https://stackoverflow.com/users/387076/gilles-so-stop-being-evil
            "\eOA" [up]
            "\e[A" [up]
            "\eOB" [down]
            "\e[B" [down]
            "\eOD" [left]
            "\e[D" [left]
            "\eOC" [right]
            "\e[C" [right]
            "M-x" 'meq/M-x)
    :deino (deino-restart (:color blue) "r"
            ("`" nil "cancel")
            ("l" meq/reload-emacs "reload")
            ("s" restart-emacs "restart"))
    :custom (alloy-implicit-naked t))
#+end_src

** meq-which-key-config.el

#+call: hash() :exports none

#+RESULTS:
: 20210821212520193609500

#+name: 20210821212520193609500
#+begin_src emacs-lisp :tangle (meq/tangle-path) :exports none
(meq/up which-key :deino (deino/which-key (:color blue :columns 4) "w"
        ("`" nil "cancel")
        ("a" cosmoem-any-popup-showing-p "any popup showing")
        ("h" meq/which-key--hide-popup "hide-popup")
        ("s" meq/which-key--show-popup "show-popup")
        ("r" meq/which-key--refresh-popup "refresh-popup")
        ("t" meq/toggle-which-key "toggle")
        ("l" meq/which-key-show-top-level "meq/toplevel")
        ("L" which-key-show-top-level "toplevel"))
    :gsetq
        (which-key-enable-extended-define-key t)
        (which-key-idle-delay 0.1)
        (which-key-idle-secondary-delay nil)
        (which-key-allow-evil-operators t)

        ;; NOTE: This will cause the which-key maps for the operator states to show up,
        ;; breaking functionality such as `d 13 <arrow-down>', etc.
        ;; (which-key-show-operator-state-maps t)

        ;; TODO: Choose a fun one!
        (which-key-separator " × ")
        ;; (which-key-separator " |-> ")

        (which-key-popup-type 'side-window)
        (which-key-side-window-location '(right bottom left top))

        ;; If this percentage is too small, the keybindings frame will appear at the bottom
        (which-key-side-window-max-width 0.5)

        (which-key-side-window-max-height 0.25))
#+end_src

** meq-cosmoem-config.el

#+call: hash() :exports none

#+RESULTS:
: 20210821211909575354500

#+name: 20210821211909575354500
#+begin_src emacs-lisp :tangle (meq/tangle-path) :exports none
(meq/upnsd cosmoem
    :upnsd-postconfig (meta)
    :config (prime ", m" map-of-infinity/body "map-of-infinity")
    :which-key-change-ryo ("," "damascus")
    :deino (map-of-infinity nil ", m"
            ("`" nil "cancel")
            ("w" deino/which-key/body "which-key")
            ("h" deino/cosmoem/body "cosmoem")
            ("d" meq/disable-all-modal-modes "disable all modal modes" :color blue)
            ("t" toggles/body "toggles")
            ("k" all-keymaps/body "all keymaps"))
        (deino/cosmoem (:color blue) ", c"
            ("`" nil "cancel")
            ("h" cosmoem-hide-all-modal-modes "hide all modal modes"))
        (toggles (:color blue) ", t" ("`" nil "cancel"))
        (all-keymaps (:color blue) ", k" ("`" nil "cancel")))
#+end_src

** meq-sorrow-config.el

#+call: hash() :exports none

#+RESULTS:
: 20210821211910346059700

#+name: 20210821211910346059700
#+begin_src emacs-lisp :tangle (meq/tangle-path) :exports none
(meq/upnsd sorrow
    :primer+ ("t" "toggles")
    :config ;; From: https://github.com/shadowrylander/sorrow#which-key-integration
        (push '((nil . "sorrow:.*:") . (nil . "")) which-key-replacement-alist))
#+end_src

* early-init.el

#+call: hash() :exports none

#+RESULTS:
: 20210604182053300746900

#+name: 20210604182053300746900
#+begin_src emacs-lisp :tangle (meq/tangle-path) :comments both
;;; $EMACSDIR/early-init.el -*- lexical-binding: t; -*-

(defvar pre-user-emacs-directory (file-name-directory load-file-name))

;; To get the latest version of `org-mode', require the load-file before
;; byte-compilation of `lib'
(add-to-list 'load-path (concat pre-user-emacs-directory "lib/org/lisp"))
(require 'org-loaddefs)

(defun meq/reload-early-init nil (interactive)
    (org-babel-load-file (concat pre-user-emacs-directory "README.org")))
(meq/reload-early-init)
#+end_src

* early-init.el

Adapted From: https://github.com/hlissner/doom-emacs/blob/develop/early-init.el

#+call: hash() :exports none

#+RESULTS:
: 20210604182053300746900

#+name: 20210604182053300746900
#+begin_src emacs-lisp :tangle (meq/tangle-path)
(defvar meq/var/phone (member "-p" command-line-args))
(delete "-p" command-line-args)

;; Emacs 27.1 introduced early-init.el, which is run before init.el, before
;; package and UI initialization happens, and before site files are loaded.

;; A big contributor to startup times is garbage collection. We up the gc
;; threshold to temporarily prevent it from running, then reset it later by
;; enabling `gcmh-mode'. Not resetting it will cause stuttering/freezes.
(setq gc-cons-threshold most-positive-fixnum)

;; In noninteractive sessions, prioritize non-byte-compiled source files to
   ;; prevent the use of stale byte-code. Otherwise, it saves us a little IO time
;; to skip the mtime checks on every *.elc file.
(setq load-prefer-newer noninteractive)

;; Adapted From:
;; Answer: https://emacs.stackexchange.com/a/31662/31428
;; User: https://emacs.stackexchange.com/users/1979/stefan
(setq initial-directory default-directory)

;; Adapted From: https://www.reddit.com/r/emacs/comments/dppmqj/do_i_even_need_to_leverage_earlyinitel_if_i_have/?utm_source=amp&utm_medium=&utm_content=post_body
(defvar default-file-name-handler-alist file-name-handler-alist)

(setq-default auto-window-vscroll nil
              file-name-handler-alist nil
              frame-inhibit-implied-resize t
              gc-cons-percentage 0.6
              inhibit-compacting-font-caches t
              package-enable-at-startup nil)

(add-hook 'after-init-hook
          (lambda ()
            (setq file-name-handler-alist default-file-name-handler-alist)
            (setq gc-cons-percentage 0.1)

            (defun meq/gc-on-lose-focus ()
              (unless (frame-focus-state)
                (garbage-collect)))

            (if (boundp 'after-focus-change-function)
                (add-function :after after-focus-change-function #'meq/gc-on-lose-focus))))

(fset 'yes-or-no-p 'y-or-n-p)
(fset 'view-hello-file 'ignore)
(fset 'display-startup-echo-area-message 'ignore)

(put 'narrow-to-region 'disabled nil)
(put 'up-case-rgion 'disabled nil)
(put 'downcase-region 'disabled nil)
(put 'erase-buffer 'disabled nil)

(push '(ns-transparent-titlebar . t) default-frame-alist)
(push '(ns-appearance . nil) default-frame-alist)
(push '(internal-border . 0) default-frame-alist)
(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(vertical-scroll-bars . 0) default-frame-alist)
(push '(left-fringe . 0) default-frame-alist)
(push '(right-fringe . 0) default-frame-alist)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Get rid of double dashes in scripts ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(when (string= (car (last command-line-args)) "--") (delete "--" command-line-args))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Define preliminary variables ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defvar meq/var/profiled t)
(defvar meq/var/profile-name (if (member "--profile" command-line-args)
    (let* ((value (nth (1+ (seq-position command-line-args "--profile")) command-line-args)))
        (unwind-protect
            value
            (delete "--profile" command-line-args)
            (delete value command-line-args))) "damascus"))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Add to the `command-line-args' ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(require 'cl)
(defun meq/push-to-cla (args)
    (dolist (arg* args)
        (let* ((arg (if (stringp arg*) arg* (symbol-name arg*)))
                (already-in-list (member arg command-line-args)))
            (unless already-in-list (add-to-list 'command-line-args arg t)))))
(cl-case (intern meq/var/profile-name)
    (nano (meq/push-to-cla '(--profile-lib profiles/nano/lisp/nano.el)))
    (graphene (meq/push-to-cla '(--profile-lib profiles/graphene/lisp/graphene.el))))
(remove-duplicates command-line-args :test 'string=)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Define other variables ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Adapted From: https://www.emacswiki.org/emacs/LoadPath#h5o-2 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; And: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Answer: https://emacs.stackexchange.com/a/55415/31428 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; User: https://emacs.stackexchange.com/users/14825/nickd ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(let ((default-directory (concat pre-user-emacs-directory "lib")))
    ;; (byte-recompile-directory default-directory nil)
    (normal-top-level-add-to-load-path '("."))
    (normal-top-level-add-subdirs-to-load-path))
(let ((default-directory (concat pre-user-emacs-directory "siluam")))
    ;; (byte-recompile-directory default-directory nil)
    (normal-top-level-add-to-load-path '("."))
    (normal-top-level-add-subdirs-to-load-path))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; We are `borg' ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(setq package-enable-at-startup nil)
(require 'borg)
(setq borg-rewrite-urls-alist '(("git@github.com:" . "https://github.com/")
                                ("git@gitlab.com:" . "https://gitlab.com/")))
(borg-initialize)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Tell straight.el about the profiles we are going to be using.
(setq straight-profiles
      '((nil . "default.el")
        ;; Packages which are pinned to a specific commit.
        (pinned . "pinned.el")))

(with-no-warnings
    (setq straight-vc-git-default-clone-depth 1)
    (setq straight-base-dir (meq/ued ".local/"))
    (setq straight-repository-branch "develop")
    (setq straight-build-dir (format "build-%s" emacs-version))
    (setq straight-cache-autoloads t)
    (setq straight-check-for-modifications '(check-on-save))
    (setq straight-repository-branch "develop")
    (setq straight-use-package-by-default t)
    ;; From: https://github.com/hartzell/straight.el/commit/882649137f73998d60741c7c8c993c7ebbe0f77a#diff-b335630551682c19a781afebcf4d07bf978fb1f8ac04c6bf87428ed5106870f5R1649
    (setq straight-disable-byte-compilation (member "--no-byte-compilation" command-line-args)))
(delete "--no-byte-compilation" command-line-args)

(eval-and-compile
  (setq straight-recipes-gnu-elpa-use-mirror t)
  (setq straight-recipes-emacsmirror-use-mirror t)
  (setq bootstrap-version 5)
  (setq bootstrap-file (concat straight-base-dir "straight/repos/straight.el/bootstrap.el")))

;; (unless (file-exists-p bootstrap-file)
;;   (with-current-buffer
;;       (url-retrieve-synchronously
;;        "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
;;        'silent 'inhibit-cookies)
;;     (goto-char (point-max))
;;     (eval-print-last-sexp)))

;; (load bootstrap-file nil 'nomessage)

;; (autoload #'straight-x-pull-all "straight-x")
;; (autoload #'straight-x-freeze-versions "straight-x")

(unless (member system-type '(windows-nt ms-dos))
    (meq/up exec-path-from-shell
        :custom
            (exec-path-from-shell-check-startup-files nil)
            (exec-path-from-shell-variables '("PATH" "MANPATH" "CACHE_HOME" "FPATH" "PYENV_ROOT"))
            (exec-path-from-shell-arguments '("-l"))
        :config
            (exec-path-from-shell-initialize)))

;; Adapted From: https://github.com/daviwil/dotfiles/blob/master/Emacs.org#native-compilation
(ignore-errors
    ;; Silence compiler warnings as they can be pretty disruptive
    (setq native-comp-async-report-warnings-errors nil)
    ;; Set the right directory to store the native comp cache
    (add-to-list 'native-comp-eln-load-path (meq/ued "eln-cache/")))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Set up `use-package' ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(with-no-warnings
  (setq use-package-verbose t)
  (setq use-package-enable-imenu-support t))
(require 'use-package)

;; use-package
<<20210601225235077502200>>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Set up cleanup mechanisms ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(use-package no-littering :demand t)
(use-package gcmh :demand t :config (gcmh-mode 1))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Set up my `use-package-extras' ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(use-package use-package-extras
    :demand t
    :init (require 'a) (require 'dash) (require 's) (require 'f)
    :config
        (meq/up meq :load-emacs-file-preconfig ("naked"))
        (meq/up leaf :use-package-preconfig
            (use-package-ensure-system-package)
            (leaf-keywords)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Set up the `user-emacs-directory' ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(setq user-emacs-directory (f-full (meq/ued* "profiles" meq/var/profile-name)))
;; (unless (string= meq/var/profile-name "doom") (byte-recompile-directory user-emacs-directory nil))
(setq custom-file (meq/ued "init.el"))
;; Adapted From:
;; Answer: https://emacs.stackexchange.com/a/18682/31428
;; User: https://emacs.stackexchange.com/users/2731/ebpa
(setq auto-save-list-file-prefix user-emacs-directory)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Implement `doom-emacs' updating ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(when (and
        (string= meq/var/profile-name "doom")
        (member "--update" command-line-args))
    (delete "--update" command-line-args)
    (call-process (meq/ued* "profiles" "doom" "bin" "doom") nil nil nil "update")
    (call-process (meq/ued* "profiles" "doom" "bin" "doom") nil nil nil "sync")
    (call-process (meq/ued* "profiles" "doom" "bin" "doom") nil nil nil "doctor"))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Set up theming ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (byte-recompile-directory (meq/ued* "themes") nil)
(add-to-list 'custom-theme-load-path (meq/ued* "themes"))
(setq custom-safe-themes t)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Perform any last-minute steps for specific profiles ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(let* ((spacemacs-path (meq/ued-profiles
                            "spacemacs"
                            "layers"
                            "+distributions"
                            "spacemacs-bootstrap")))
    (cl-case (intern meq/var/profile-name)
        (doom (load (meq/ued-lib "ido-completing-read+" "ido-completing-read+.el")))
        (spacemacs (progn
                        (load (concat spacemacs-path "packages.el"))
                        (load (concat spacemacs-path "funcs.el"))
                        (spacemacs-bootstrap/init-use-package)))
        (patrick (advice-add #'reload-config :override #'(lambda nil (interactive)
                    (org-babel-load-file (meq/ued-profiles "patrick" "readme.org")))))
        (alhassy (require 'quelpa-use-package))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Load the profile's `early-init' if it exists ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun meq/load-from-cla (arg &optional byte-compile)
    (eval `(meq/when-item-in-cla ,arg
        (let* ((item (meq/get-next-in-cla ,arg))
                (file (expand-file-name item))
                (exists (f-exists? file))
                (is-dir (and exists (f-directory? file)))
                (dir (if is-dir file (f-dirname file))))
            (message file)
            (if (not exists)
                (eval (intern item))
                ;; (when ,byte-compile (byte-recompile-directory dir nil))
                (add-to-list 'load-path dir)
                (unless is-dir (load file)))))))
(if (member "--profile-early-init" command-line-args)
    (meq/load-from-cla "--profile-early-init")
    (meq/cl "early-init.el"))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Use an alternate `early-lib' ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(meq/load-from-cla "--profile-early-lib" t)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src

** use-package

#+call: hash() :exports none

#+RESULTS:
: 20210601225235077502200

#+name: 20210601225235077502200
#+begin_src emacs-lisp
<<20210601225231422834500>>
(setq use-package-always-demand (or (member "--always-demand" command-line-args) (daemonp)))
(delete "--always-demand" command-line-args)
#+end_src

*** always defer package loading

Quoted from [[https://github.com/jwiegley/use-package#loading-packages-in-sequence][Use-Package's Loading packages in sequence]]:

#+begin_quote
NOTE: pay attention if you set use-package-always-defer to t, and also use the :after keyword, as you will need to specify how the
declared package is to be loaded: e.g., by some :bind. If you're not using one of the mechanisms that registers autoloads, such as
:bind or :hook, and your package manager does not provide autoloads, it's possible that without adding :defer 2 to those declarations,
your package will never be loaded.
#+end_quote

Quoted from [[https://github.com/jwiegley/use-package#notes-about-lazy-loading][Use-Package's Notes about lazy loading]]:

#+begin_quote
In almost all cases you don't need to manually specify :defer t. This is implied whenever :bind or :mode or :interpreter is used.
Typically, you only need to specify :defer if you know for a fact that some other package will do something to cause your package to
load at the appropriate time, and thus you would like to defer loading even though use-package isn't creating any autoloads for you.
You can override package deferral with the :demand keyword. Thus, even if you use :bind, using :demand will force loading to occur
immediately and not establish an autoload for the bound key.
#+end_quote

Quoted from [[https://github.com/jwiegley/use-package#modes-and-interpreters][Use-Package's Modes and interpreters]]:

#+begin_quote
Similar to :bind, you can use :mode and :interpreter to establish a deferred binding within the auto-mode-alist and interpreter-mode-alist variables.
...
If you aren't using :commands, :bind, :bind*, :bind-keymap, :bind-keymap*, :mode, :interpreter, or :hook
(all of which imply :defer; see the docstring for use-package for a brief description of each), you can still defer loading with the :defer keyword...
#+end_quote

Quoted from [[https://github.com/jwiegley/use-package#magic-handlers][Use-Package's Magic handlers]]:

#+begin_quote
Similar to :mode and :interpreter, you can also use :magic and :magic-fallback to cause certain function to be run if the beginning of a file matches
a given regular expression.
...
This registers an autoloaded command for pdf-view-mode, defers loading of pdf-tools, and runs pdf-view-mode if the beginning of a buffer matches the string "%PDF".
#+end_quote

Quoted from [[https://github.com/Kungsgeten/ryo-modal#use-package-keyword][RYO-Modal's Use-package keyword]]:

#+begin_quote
Ryo-modal also provides a use-package keyword: :ryo, which is similar to :bind in that it implies :defer t and create autoloads for the bound commands.
The keyword is followed by one or more key-binding commands, using the same syntax as used by ryo-modal-keys...
#+end_quote

Quoted from [[https://github.com/noctuid/general.el#use-package-keywords][General's Use-package Keywords]]:

#+begin_quote
:general is similar to :bind in that it implies :defer t whenever there are bound commands that can be autoloaded
(e.g. it will not imply :defer t if the only bound command is to a lambda, for example). Whenever autoloadable commands are bound,
use-package will create autoloads for them (though this is usually not necessary).
#+end_quote

Quoted from [[https://github.com/noctuid/general.el#ghook-keyword][General's :ghook Keyword]]:

#+begin_quote
:ghook is intended to be used to add a package’s minor mode enabling function to a user-specified hook, so that when hook is run,
the package will be loaded and the mode enabled. This means that :ghook will usually imply :defer t. While it does not always imply :defer t,
it will add any non-lambda functions to :commands (this is the same behavior as :hook).
Though this is usually unnecessary (the commands probably already have autoloads), it will in turn imply :defer t.
#+end_quote

Quoted from [[https://github.com/noctuid/general.el#gfhook-keyword][General's :gfhook Keyword]]:

#+begin_quote
Unlike :ghook, :gfhook never adds functions to :commands and therefore never implies :defer t.
This is because the functions specified are ones that should be run when turning on (or toggling) the mode(s) the package provides.
The specified functions are external to the package, could be called elsewhere, and therefore should not trigger the package to load.
#+end_quote

Also see [[https://github.com/jwiegley/use-package/issues/738#issuecomment-447631609][this comment]].

Note that I assume that [[https://github.com/jwiegley/use-package#use-package-chords][chords]] also defer and create autoloads.

And in my experience... Not a good idea; much too confusing. Use
[[https://www.reddit.com/r/emacs/comments/j2xezg/usepackage_best_practices/][the arguments here]] to decide whether to use this or =:defer <n>= instead.

#+call: hash() :exports none

#+RESULTS:
: 20210601225231422834500

#+name: 20210601225231422834500
#+begin_src emacs-lisp
(setq use-package-always-defer (member "--always-defer" command-line-args))
(delete "--always-defer" command-line-args)
#+end_src

* init.el

#+call: hash() :exports none

#+RESULTS:
: 20210804184605617540800

#+name: 20210804184605617540800
#+begin_src emacs-lisp :tangle (meq/tangle-path) :comments link
;;; $EMACSDIR/init.el -*- lexical-binding: t; -*-
(when (version< emacs-version "27") (load (concat (file-name-directory load-file-name) "early-init.el")))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Set up the `use-package' keywords for `exwm' ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(mapc #'(lambda (config) (interactive)
            (load (meq/ued-lib (concat "meq-" (symbol-name config) "-config"))))
    '(hydra alloy which-key cosmoem sorrow))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Set up `exwm' ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(load (meq/ued-lib "meq-exwm-config"))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Load the profile's `early-init' if it exists ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(if (member "--profile-early-init" command-line-args)
    (meq/load-from-cla "--profile-early-init")
    (meq/cl "early-init.el"))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Use an alternate `lib' ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(meq/load-from-cla "--profile-lib")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src

* profiles
** damascus
*** init.el

#+call: hash() :exports none

#+RESULTS:
: 20210811234927547343000

#+name: 20210811234927547343000
#+begin_src emacs-lisp :tangle (meq/tangle-path) :comments link
;;; $EMACSDIR/init.el -*- lexical-binding: t; -*-
(when (version< emacs-version "27") (load (meq/ued "early-init.el")))

(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(meq/var/current-theme 'ghostfreak-green-dark)
 '(meq/var/current-theme-mode "dark")
 '(safe-local-variable-values '((eval message "eval 1"))))
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 )

(org-babel-load-file (meq/ued "README.org"))
#+end_src

** graphene
*** init.el

#+call: hash() :exports none

#+RESULTS:
: 20210818012945822500800

#+name: 20210818012945822500800
#+begin_src emacs-lisp :tangle (meq/tangle-path) :comments link
(meq/up project-persist)
(meq/up ido-completing-read+)
(meq/up ppd-sr-speedbar)
(meq/up smartparens)
(meq/up company)
(meq/up web-mode)
(meq/up smex)
(meq/up flycheck)

(with-eval-after-load 'graphene (cond ((or
            (equal system-type 'windows-nt)
            (equal system-type 'ms-dos))
        (require 'graphene-windows-defaults))
    ((equal system-type 'darwin) (require 'graphene-osx-defaults))
    (t (require 'graphene-linux-defaults))))
(load-theme 'dracula-purple-dark)
#+end_src