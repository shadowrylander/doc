#+setupfile: ./settings.org
#+include: ./settings.org
#+property: header-args:emacs-lisp+ :comments none

The tangle functions are adapted from [[https://emacs.stackexchange.com/a/29884/31428][this answer on the emacs Stack Exchange]],
which was written by [[https://emacs.stackexchange.com/users/2710/andrew-swann][Andrew Swann]].

* wtt-pre

#+call: hash() :exports none

#+RESULTS:
: 20210821132334835661400

#+name: 20210821132334835661400
#+begin_src emacs-lisp
(load (concat (getenv "HOME") "/.emacs.d/early-init.el"))
(meq/up markdown-mode :mode ("\\.md\\'")
    :use-package-postconfig (yasnippet)
    :upnsd-preconfig (titan :custom (meq/var/titan-snippets-dir (meq/ued-siluam "titan" "snippets"))))
#+end_src

* wtt-post

#+call: hash() :exports none

#+RESULTS:
: 20210821140509092087900

#+name: 20210821140509092087900
#+begin_src emacs-lisp
(meq/insert-snippet "markdown titan template")
(save-buffer)
#+end_src

* wtt.sh

#+call: hash() :exports none

#+RESULTS:
: 20210601225227507463400

#+name: 20210601225227507463400
#+begin_src emacs-lisp :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
":"; exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-
(princ (format-time-string "%Y%m%d%H%M%S%N")) (terpri)
#+end_src

* wtt.fell.sh

#+call: hash() :exports none

#+RESULTS:
: 20210820041859058805800

#+name: 20210820041859058805800
#+begin_src emacs-lisp :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
":"; exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-
<<20210821132334835661400>>
(meq/upnsd fell
    :custom (meq/var/fell-snippets-dir (meq/ued-siluam "fell" "snippets"))
    :mode ("\\.fell\\.md\\'" . fell-markdown-mode))
(find-file (concat (meq/timestamp) ".fell.md"))
<<20210821140509092087900>>
#+end_src

* wtt.doc.sh

#+call: hash() :exports none

#+RESULTS:
: 20210820041900953120200

#+name: 20210820041900953120200
#+begin_src emacs-lisp :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
":"; exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-
<<20210821132334835661400>>
(meq/upnsd doc
    :custom (meq/var/doc-snippets-dir (meq/ued-siluam "doc" "snippets"))
    :mode ("\\.doc\\.md\\'" . doc-markdown-mode))
(find-file (concat (meq/timestamp) ".doc.md"))
<<20210821140509092087900>>
#+end_src

* vterm-start.sh

#+call: hash() :exports none

#+RESULTS:
: 20210710215312854336800

#+name: 20210710215312854336800
#+begin_src sh :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
tmux new -As0
#+end_src

* org-tangle.sh

Adapted from: https://github.com/hlissner/doom-emacs/blob/develop/bin/org-tangle

#+call: hash() :exports none

#+RESULTS:
: 20210601225359807196100

#+name: 20210601225359807196100
#+begin_src emacs-lisp :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
":"; exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-

(setq org-confirm-babel-evaluate nil)

(require 'cl-lib)
(require 'ox)
(require 'ob-tangle)

<<20210601225401786848500>>

(defun usage ()
  (with-temp-buffer
    (insert (format "%s %s [OPTIONS] [TARGETS...]\n"
                    "[1mUsage:[0m"
                    (file-name-nondirectory load-file-name))
            "\n"
            "A command line interface for tangling org-mode files. TARGETS can be\n"
            "files or folders (which are searched for org files recursively).\n"
            "\n"
            "This is useful for literate configs that rely on command line\n"
            "workflows to build it.\n"
            "\n"
            "[1mExample:[0m\n"
            "  org-tangle some-file.org\n"
            "  org-tangle literate/config/\n"
            "  org-tangle -p -l sh scripts.org > do_something.sh\n"
            "  org-tangle -p -l python -t tagA -t tagB file.org | python\n"
            "\n"
            "[1mOptions:[0m\n"
            "  -a --all\t\tTangle all blocks by default\n"
            "  -l --lang LANG\tOnly tangle blocks written in LANG\n"
            "  -p --print\t\tPrint tangled output to stdout than to files\n"
            "  -t --tag TAG\n"
            "     --and TAG\n"
            "     --or TAG\n"
            "    Lets you tangle org blocks by tag. You may have more than one\n"
            "    of these options.\n")
    (princ (buffer-string))))

(defun *org-babel-tangle (orig-fn &rest args)
  "Don't write tangled blocks to files, print them to stdout."
  (cl-letf (((symbol-function 'write-region)
             (lambda (start end filename &optional append visit lockname mustbenew)
               (princ (buffer-string)))))
    (apply orig-fn args)))

(defun *org-babel-tangle-collect-blocks (&optional language tangle-file)
  "Like `org-babel-tangle-collect-blocks', but will ignore blocks that are in
trees with the :notangle: tag."
  (let ((counter 0) last-heading-pos blocks)
    (org-babel-map-src-blocks (buffer-file-name)
      (let ((current-heading-pos
             (org-with-wide-buffer
              (org-with-limited-levels (outline-previous-heading)))))
        (if (eq last-heading-pos current-heading-pos) (cl-incf counter)
          (setq counter 1)
          (setq last-heading-pos current-heading-pos)))
      (unless (org-in-commented-heading-p)
        (require 'org)
        (let* ((tags (org-get-tags-at))
               (info (org-babel-get-src-block-info 'light))
               (src-lang (nth 0 info))
               (src-tfile (cdr (assq :tangle (nth 2 info)))))
          (cond ((member "notangle" tags))

                ((and (or or-tags and-tags)
                      (or (not and-tags)
                          (let ((a (cl-intersection and-tags tags :test #'string=))
                                (b and-tags))
                            (not (or (cl-set-difference a b :test #'equal)
                                     (cl-set-difference b a :test #'equal)))))
                      (or (not or-tags)
                          (cl-intersection or-tags tags :test #'string=))
                      t))

                ((or (not (or all-blocks src-tfile))
                     (string= src-tfile "no")  ; tangle blocks by default
                     (and tangle-file (not (equal tangle-file src-tfile)))
                     (and language (not (string= language src-lang)))))

                ;; Add the spec for this block to blocks under its language.
                ((let ((by-lang (assoc src-lang blocks))
                       (block (org-babel-tangle-single-block counter)))
                   (if by-lang
                       (setcdr by-lang (cons block (cdr by-lang)))
                     (push (cons src-lang (list block)) blocks))))))))
    ;; Ensure blocks are in the correct order.
    (mapcar (lambda (b) (cons (car b) (nreverse (cdr b)))) blocks)))
(advice-add #'org-babel-tangle-collect-blocks :override #'*org-babel-tangle-collect-blocks)

(defvar all-blocks nil)
(defvar and-tags nil)
(defvar or-tags nil)
(let (lang srcs and-tags or-tags)
  (pop argv)
  (while argv
    (let ((arg (pop argv)))
      (pcase arg
        ((or "-h" "--help")
         (usage)
         (error ""))
        ((or "-a" "--all")
         (setq all-blocks t))
        ((or "-l" "--lang")
         (setq lang (pop argv)))
        ((or "-p" "--print")
         (advice-add #'org-babel-tangle :around #'*org-babel-tangle))
        ((or "-t" "--tag" "--and")
         (push (pop argv) and-tags))
        ("--or"
         (push (pop argv) or-tags))
        ((guard (string-match-p "^--lang=" arg))
         (setq lang (cadr (split-string arg "=" t t))))
        ((guard (file-directory-p arg))
         (setq srcs
               (append (directory-files-recursively arg "\\.org$")
                       srcs)))
        ((guard (file-exists-p arg))
         (push arg srcs))
        (_ (error "Unknown option or file: %s" arg)))))

  (dolist (file srcs)
    (message (format "\n\nNow tangling %s:\n" file))
    (let ((backup (make-temp-file (file-name-base file) nil ".backup.org")))
      (unwind-protect
          ;; Prevent slow hooks from interfering
          (let (org-mode-hook)
            ;; We do the ol' switcheroo because `org-babel-tangle' writes
            ;; changes to the current file, which would be imposing on the user.
            (copy-file file backup t)
            (with-current-buffer (find-file-noselect file)

              ;; Tangling doesn't expand #+INCLUDE directives, so we do it
              ;; ourselves, since includes are so useful for literate configs!
              ;; (org-export-expand-include-keyword)

              (org-babel-tangle nil nil lang)))
        (ignore-errors (copy-file backup file t))
        (ignore-errors (delete-file backup)))))
  (kill-emacs 0))
#+end_src

* org-tangle-functions.el

#+call: hash() :exports none

#+RESULTS:
: 20210601225401786848500

#+name: 20210601225401786848500
#+begin_src emacs-lisp :tangle (meq/tangle-path)
(let* ((file (cond
                ((file-exists-p "~/.emacs.d/settings.org") "~/.emacs.d/settings.org")
                ((file-exists-p "home/.emacs.d/settings.org") "home/.emacs.d/settings.org"))))
    (when file (org-babel-lob-ingest file)))
(let* ((file (cond
                ((file-exists-p "~/.emacs.d/strange.aiern.org") "~/.emacs.d/strange.aiern.org")
                ((file-exists-p "home/.emacs.d/strange.aiern.org") "home/.emacs.d/strange.aiern.org"))))
    (when file (org-babel-lob-ingest file)))

(defun meq/get-header nil (interactive)
    (nth 4 (org-heading-components)))
(defun meq/tangle-path nil (interactive)
    (string-remove-prefix "/" (concat
        (org-format-outline-path (org-get-outline-path)) "/"
            (meq/get-header))))
(defun meq/get-theme-from-header nil (interactive)
    (string-remove-suffix "-theme.el" (meq/get-header)))
#+end_src

* .gitconfig

#+begin_src conf :tangle (meq/tangle-path)
[remote "aiern"]
    url = git@github.com:shadowrylander/aiern
    fetch = +refs/heads/*:refs/remotes/aiern/*
[remote "doom-aiern-modeline"]
    url = git@github.com:shadowrylander/doom-aiern-modeline
    fetch = +refs/heads/*:refs/remotes/doom-aiern-modeline/*
[remote "alloy"]
    url = git@github.com:shadowrylander/alloy.git
    fetch = +refs/heads/*:refs/remotes/alloy/*
[remote "alamode"]
    url = git@github.com:shadowrylander/alamode
    fetch = +refs/heads/*:refs/remotes/alamode/*
[remote "use-package-extras"]
    url = git@github.com:shadowrylander/use-package-extras
    fetch = +refs/heads/*:refs/remotes/use-package-extras/*
[remote "deino"]
    url = git@github.com:shadowrylander/deino
    fetch = +refs/heads/*:refs/remotes/deino/*
[remote "use-package-deino"]
    url = git@github.com:shadowrylander/use-package-deino
    fetch = +refs/heads/*:refs/remotes/use-package-deino/*
[remote "sorrow"]
    url = git@github.com:shadowrylander/sorrow
    fetch = +refs/heads/*:refs/remotes/sorrow/*
[remote "lode"]
    url = git@github.com:shadowrylander/lode
    fetch = +refs/heads/*:refs/remotes/lode/*
[remote "meq"]
    url = git@github.com:shadowrylander/meq.git
    fetch = +refs/heads/*:refs/remotes/meq/*
[remote "aiern-god-state"]
    url = git@github.com:shadowrylander/aiern-god-state
    fetch = +refs/heads/*:refs/remotes/aiern-god-state/*
[remote "janus"]
    url = git@github.com:shadowrylander/janus
    fetch = +refs/heads/*:refs/remotes/janus/*
[remote "titan"]
    url = git@github.com:shadowrylander/titan
    fetch = +refs/heads/*:refs/remotes/titan/*
[remote "fell"]
    url = git@github.com:shadowrylander/fell
    fetch = +refs/heads/*:refs/remotes/fell/*
[remote "doc"]
    url = git@github.com:shadowrylander/doc
    fetch = +refs/heads/*:refs/remotes/doc/*
[remote "cosmoem"]
    url = git@gitlab.com:shadowrylander/cosmoem
    fetch = +refs/heads/*:refs/remotes/cosmoem/*
[remote "cosmog"]
    url = git@github.com:shadowrylander/cosmog
    fetch = +refs/heads/*:refs/remotes/cosmog/*
[remote "prime"]
    url = git@github.com:shadowrylander/prime
    fetch = +refs/heads/*:refs/remotes/prime/*
[remote "uru"]
    url = git@github.com:shadowrylander/uru
    fetch = +refs/heads/*:refs/remotes/uru/*
[remote "meta"]
    url = git@github.com:shadowrylander/meta
    fetch = +refs/heads/*:refs/remotes/meta/*
[remote "riot"]
    url = git@github.com:shadowrylander/riot
    fetch = +refs/heads/*:refs/remotes/riot/*
[remote "evil-evilified-state"]
    url = git@github.com:shadowrylander/evil-evilified-state
    fetch = +refs/heads/*:refs/remotes/evil-evilified-state/*
[remote "helm-ido-like-guide"]
    url = git@github.com:shadowrylander/helm-ido-like-guide
    fetch = +refs/heads/*:refs/remotes/helm-ido-like-guide/*
#+end_src

* makefile

#+call: hash() :exports none

#+RESULTS:
: 20210622004216528168500

#+name: 20210622004216528168500
#+begin_src makefile :tangle (meq/tangle-path)
# Adapted From: https://www.systutorials.com/how-to-get-the-full-path-and-directory-of-a-makefile-itself/
.RECIPEPREFIX := |
.DEFAULT_GOAL := emacs

mkfilePath := $(abspath $(lastword $(MAKEFILE_LIST)))
mkfileDir := $(dir $(mkfilePath))
test := emacs --bg-daemon=test
killTest := emacsclient -s test -e "(kill-emacs)"

init:
|git -C $(mkfileDir) config include.path "$(mkfileDir)/.gitconfig"
|-sudo cp $(mkfileDir)/git-subtree $$(git --exec-path)/

subinit:
|git -C $(mkfileDir) submodule update --init --depth 1 --recursive
|git -C $(mkfileDir) submodule sync
|-git -C $(mkfileDir) submodule add --depth 1 -f https://code.orgmode.org/bzg/org-mode.git lib/org
|-git -C $(mkfileDir) submodule add --depth 1 -f https://github.com/alhassy/alhassy.github.io.git lib/alhassy
|-git -C $(mkfileDir) submodule add --depth 1 -f https://github.com/emacscollective/borg.git lib/borg
|-git -C $(mkfileDir) submodule add --depth 1 -f https://github.com/emacscollective/closql.git lib/closql
|-git -C $(mkfileDir) submodule add --depth 1 -f https://github.com/emacscollective/epkg.git lib/epkg
|-git -C $(mkfileDir) submodule add --depth 1 -f https://github.com/magnars/dash.el.git lib/dash
|-git -C $(mkfileDir) submodule add --depth 1 -f https://github.com/magnars/s.el.git lib/s
|-git -C $(mkfileDir) submodule add --depth 1 -f https://github.com/plexus/a.el.git lib/a
|-git -C $(mkfileDir) submodule add --depth 1 -f https://github.com/rejeep/f.el.git lib/f
|-git -C $(mkfileDir) submodule add --depth 1 -f https://github.com/skeeto/emacsql.git lib/emacsql
|-git -C $(mkfileDir) submodule add --depth 1 -f https://github.com/emacscollective/epkgs.git epkgs
|-git -C $(mkfileDir) submodule add --depth 1 -f https://github.com/emacscollective/epkgs.git var/epkgs
# |git -C $(mkfileDir) submodule foreach 'git -C $$toplevel config submodule.$$name.ignore all'
|cd $(mkfileDir)/lib/org; make all; make autoloads

pull: init
|git -C $(mkfileDir) pull
|git -C $(mkfileDir) subtree pull-all

add:
|git submodule foreach git stash
|git -C $(mkfileDir) add .

commit:
|-git -C $(mkfileDir) commit --allow-empty-message -am ""

cammit: add commit

push-only: cammit
|-git -C $(mkfileDir) push

push: push-only init
|git -C $(mkfileDir) subtree prune
|-git -C $(mkfileDir) subtree push-all

tangle-setup:
|cp $(mkfileDir)/org-tangle.sh $(mkfileDir)/backup-tangle.sh
|chmod +x $(mkfileDir)/org-tangle.sh $(mkfileDir)/backup-tangle.sh

tangle: tangle-setup
|yes yes | fd . $(mkfileDir) \
    -HId 1 -e org \
    -E testing.aiern.org \
    -E resting.aiern.org \
    -x $(mkfileDir)/backup-tangle.sh
|yes yes | fd . $(mkfileDir)/siluam \
    -HIe org \
    -x $(mkfileDir)/backup-tangle.sh
|fd . $(mkfileDir) \
    -HIe sh \
    -E .local \
    -E lib \
    -E var \
    -x chmod +x

subtree-prep: tangle push-only

pre-test: subinit

test: pre-test
|emacs

test-doom: pre-test
|emacs --doom

test-graphene: pre-test
|emacs --graphene

test-nano: pre-test
|emacs --nano

pest: pre-test
|emacs -p

update-test: pre-test
|emacs --update

no-config-test:
|emacs -Q

test-and-kill-pre: pre-test
|-emacsclient -s test -e "(kill-emacs)"

test-and-kill: test-and-kill-pre
|$(test)
|$(killTest)

test-new-and-kill: test-and-kill-pre
|$(test) -Q
|$(killTest)

test-update-and-kill: test-and-kill-pre
|$(test) --update
|$(killTest)

test-update-doom-and-kill: test-and-kill-pre
|$(test) --udoom
|$(killTest)

test-update-graphene-and-kill: test-and-kill-pre
|$(test) --graphene --update
|$(killTest)

test-update-nano-and-kill: test-and-kill-pre
|$(test) --nano --update
|$(killTest)

delete-doom:
|rm -rf $(mkfileDir)/profiles/doom/.local

delete:
|rm -rf $(mkfileDir)/profiles/damascus/.local

delete-graphene:
|rm -rf $(mkfileDir)/profiles/graphene/.local

delete-nano:
|rm -rf $(mkfileDir)/profiles/nano/.local

emacs: tangle test
remacs: delete tangle test-update-and-kill test
doom-remacs: delete-doom tangle test-update-doom-and-kill test-doom
graphene-remacs: delete-graphene tangle test-update-graphene-and-kill test-graphene
nano-remacs: delete-nano tangle test-update-nano-and-kill test-nano
super-push: tangle push
super-push-only: tangle push-only
#+end_src

* lib
** damascus.el

#+call: hash() :exports none

#+RESULTS:
: 20210616175359970389700

#+name: 20210616175359970389700
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; damascus.el --- a simple package                     -*- lexical-binding: t; -*-

;; Copyright (C) 2021  Jeet Ray

;; Author: Jeet Ray <aiern@protonmail.com>
;; Keywords: lisp
;; Version: 0.0.1

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; Put a description of the package here

;;; Code:

;; code goes here

(provide 'damascus)
;;; damascus.el ends here
#+end_src

* early-init.el

#+call: hash() :exports none

#+RESULTS:
: 20210604182053300746900

#+name: 20210604182053300746900
#+begin_src emacs-lisp :tangle (meq/tangle-path) :comments link
;;; $EMACSDIR/early-init.el -*- lexical-binding: t; -*-
(defvar pre-user-emacs-directory (file-name-directory load-file-name))

;; To get the latest version of `org-mode', require the load-file before
;; byte-compilation of `lib'
(add-to-list 'load-path (concat pre-user-emacs-directory "lib/org/lisp"))
(require 'org-loaddefs)

;; Adapted From: https://github.com/emacscollective/borg/blob/master/borg.el#L912
(defun meq/call (program buffer-name &rest args)
  (let ((process-connection-type nil)
        (buffer (generate-new-buffer buffer-name)))
    (if (eq (apply #'call-process program nil buffer nil args) 0)
        (kill-buffer buffer)
      (with-current-buffer buffer
        (special-mode))
      (pop-to-buffer buffer)
      (error "%s failed" program))))

;; Adapted From: https://code.orgmode.org/bzg/org-mode/src/master/lisp/org.el#L222
(defun meq/org-babel-load-file-advice (file &optional compile)
  "Load Emacs Lisp source code blocks in the Org FILE.
This function exports the source code using `org-babel-tangle'
and then loads the resulting file using `load-file'.  With
optional prefix argument COMPILE, the tangled Emacs Lisp file is
byte-compiled before it is loaded."
  (interactive "fFile to load: \nP")
  (let ((tangled-file (concat (file-name-sans-extension file) ".el")))
    ;; Tangle only if the Org file is newer than the Elisp file.
    (unless (org-file-newer-than-p
                tangled-file
                (file-attribute-modification-time
                    (file-attributes (file-truename file))))
        (meq/call (concat pre-user-emacs-directory "org-tangle.sh") "*literally-configuring*" file))
    (if compile
        (progn
            (byte-compile-file tangled-file)
            (load tangled-file)
            (message "Compiled and loaded %s" tangled-file))
        (load-file tangled-file)
        (message "Loaded %s" tangled-file))))

(advice-add #'org-babel-load-file :override #'meq/org-babel-load-file-advice)

(defun meq/reload-early-init nil (interactive)
    (org-babel-load-file (concat pre-user-emacs-directory "README.org") t))
(meq/reload-early-init)
#+end_src

* init.el

#+call: hash() :exports none

#+RESULTS:
: 20210804184605617540800

#+name: 20210804184605617540800
#+begin_src emacs-lisp :tangle (meq/tangle-path) :comments link
;;; $EMACSDIR/init.el -*- lexical-binding: t; -*-
(when (version< emacs-version "27") (load (concat
                                            (file-name-directory load-file-name)
                                            "early-init.el")))

(defun meq/reload-first-init nil (interactive) (meq/cl (meq/ued* "FEEDME.org")))
(meq/reload-first-init)
#+end_src