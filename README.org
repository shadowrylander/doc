#!/usr/bin/env mdsh

# TODO: Implement saku as well

#+property: header-args -n -r -l "[{(<%s>)}]" :tangle-mode (identity 0444) :noweb yes :mkdirp yes

# Adapted From:
# Answer: https://stackoverflow.com/a/65232183/10827766
# User: https://stackoverflow.com/users/776405/whil
#+startup: show3levels

#+name: username
#+begin_src text :exports none
shadowrylander
#+end_src

#+name: hash-deprecated
#+begin_src emacs-lisp :var name="" :exports none
(md5 (concat (replace-regexp-in-string "/" "" (
    org-format-outline-path (org-get-outline-path))) (
        nth 4 (org-heading-components)) name))
#+end_src

#+name: hash
#+begin_src emacs-lisp :exports none
(format-time-string "%Y%m%d%H%M%S%N")
#+end_src

The tangle functions are adapted from [[https://emacs.stackexchange.com/a/29884/31428][this answer on the emacs Stack Exchange]],
which was written by [[https://emacs.stackexchange.com/users/2710/andrew-swann][Andrew Swann]].

* As John Oliver Would Say: "Like Chemacs[2], but worse."

* wtt-pre

#+call: hash() :exports none

#+RESULTS:
: 20210821132334835661400

#+name: 20210821132334835661400
#+begin_src emacs-lisp
(load (concat (getenv "HOME") "/.emacs.d/early-init.el"))
(meq/up markdown-mode :mode ("\\.md\\'")
    :use-package-postconfig (yasnippet)
    :upnsd-postconfig (titan))
#+end_src

* wtt-post

#+call: hash() :exports none

#+RESULTS:
: 20210821140509092087900

#+name: 20210821140509092087900
#+begin_src emacs-lisp
(meq/insert-snippet "markdown titan template")
(save-buffer)
#+end_src

* wtt.sh

#+call: hash() :exports none

#+RESULTS:
: 20210601225227507463400

#+name: 20210601225227507463400
#+begin_src emacs-lisp :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
":"; exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-
(princ (format-time-string "%Y%m%d%H%M%S%N")) (terpri)
#+end_src

* wtt.fell.sh

#+call: hash() :exports none

#+RESULTS:
: 20210820041859058805800

#+name: 20210820041859058805800
#+begin_src emacs-lisp :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
":"; exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-
<<20210821132334835661400>>
(meq/upnsd fell :mode ("\\.fell\\.md\\'" . fell-md-mode))
(find-file (concat (meq/timestamp) ".fell.md"))
<<20210821140509092087900>>
#+end_src

* wtt.doc.sh

#+call: hash() :exports none

#+RESULTS:
: 20210820041900953120200

#+name: 20210820041900953120200
#+begin_src emacs-lisp :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
":"; exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-
<<20210821132334835661400>>
(meq/upnsd doc :mode ("\\.doc\\.md\\'" . doc-md-mode))
(find-file (concat (meq/timestamp) ".doc.md"))
<<20210821140509092087900>>
#+end_src

* vterm-start.sh

#+call: hash() :exports none

#+RESULTS:
: 20210710215312854336800

#+name: 20210710215312854336800
#+begin_src sh :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
tmux new -As0
#+end_src

* org-tangle.sh

Adapted from: https://github.com/hlissner/doom-emacs/blob/develop/bin/org-tangle

#+call: hash() :exports none

#+RESULTS:
: 20210601225359807196100

#+name: 20210601225359807196100
#+begin_src emacs-lisp :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
":"; exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-

(setq org-confirm-babel-evaluate nil)

(require 'cl-lib)
(require 'ox)
(require 'ob-tangle)

<<20210601225401786848500>>

(defun usage ()
  (with-temp-buffer
    (insert (format "%s %s [OPTIONS] [TARGETS...]\n"
                    "[1mUsage:[0m"
                    (file-name-nondirectory load-file-name))
            "\n"
            "A command line interface for tangling org-mode files. TARGETS can be\n"
            "files or folders (which are searched for org files recursively).\n"
            "\n"
            "This is useful for literate configs that rely on command line\n"
            "workflows to build it.\n"
            "\n"
            "[1mExample:[0m\n"
            "  org-tangle some-file.org\n"
            "  org-tangle literate/config/\n"
            "  org-tangle -p -l sh scripts.org > do_something.sh\n"
            "  org-tangle -p -l python -t tagA -t tagB file.org | python\n"
            "\n"
            "[1mOptions:[0m\n"
            "  -a --all\t\tTangle all blocks by default\n"
            "  -l --lang LANG\tOnly tangle blocks written in LANG\n"
            "  -p --print\t\tPrint tangled output to stdout than to files\n"
            "  -t --tag TAG\n"
            "     --and TAG\n"
            "     --or TAG\n"
            "    Lets you tangle org blocks by tag. You may have more than one\n"
            "    of these options.\n")
    (princ (buffer-string))))

(defun *org-babel-tangle (orig-fn &rest args)
  "Don't write tangled blocks to files, print them to stdout."
  (cl-letf (((symbol-function 'write-region)
             (lambda (start end filename &optional append visit lockname mustbenew)
               (princ (buffer-string)))))
    (apply orig-fn args)))

(defun *org-babel-tangle-collect-blocks (&optional language tangle-file)
  "Like `org-babel-tangle-collect-blocks', but will ignore blocks that are in
trees with the :notangle: tag."
  (let ((counter 0) last-heading-pos blocks)
    (org-babel-map-src-blocks (buffer-file-name)
      (let ((current-heading-pos
             (org-with-wide-buffer
              (org-with-limited-levels (outline-previous-heading)))))
        (if (eq last-heading-pos current-heading-pos) (cl-incf counter)
          (setq counter 1)
          (setq last-heading-pos current-heading-pos)))
      (unless (org-in-commented-heading-p)
        (require 'org)
        (let* ((tags (org-get-tags-at))
               (info (org-babel-get-src-block-info 'light))
               (src-lang (nth 0 info))
               (src-tfile (cdr (assq :tangle (nth 2 info)))))
          (cond ((member "notangle" tags))

                ((and (or or-tags and-tags)
                      (or (not and-tags)
                          (let ((a (cl-intersection and-tags tags :test #'string=))
                                (b and-tags))
                            (not (or (cl-set-difference a b :test #'equal)
                                     (cl-set-difference b a :test #'equal)))))
                      (or (not or-tags)
                          (cl-intersection or-tags tags :test #'string=))
                      t))

                ((or (not (or all-blocks src-tfile))
                     (string= src-tfile "no")  ; tangle blocks by default
                     (and tangle-file (not (equal tangle-file src-tfile)))
                     (and language (not (string= language src-lang)))))

                ;; Add the spec for this block to blocks under its language.
                ((let ((by-lang (assoc src-lang blocks))
                       (block (org-babel-tangle-single-block counter)))
                   (if by-lang
                       (setcdr by-lang (cons block (cdr by-lang)))
                     (push (cons src-lang (list block)) blocks))))))))
    ;; Ensure blocks are in the correct order.
    (mapcar (lambda (b) (cons (car b) (nreverse (cdr b)))) blocks)))
(advice-add #'org-babel-tangle-collect-blocks :override #'*org-babel-tangle-collect-blocks)

(defvar all-blocks nil)
(defvar and-tags nil)
(defvar or-tags nil)
(let (lang srcs and-tags or-tags)
  (pop argv)
  (while argv
    (let ((arg (pop argv)))
      (pcase arg
        ((or "-h" "--help")
         (usage)
         (error ""))
        ((or "-a" "--all")
         (setq all-blocks t))
        ((or "-l" "--lang")
         (setq lang (pop argv)))
        ((or "-p" "--print")
         (advice-add #'org-babel-tangle :around #'*org-babel-tangle))
        ((or "-t" "--tag" "--and")
         (push (pop argv) and-tags))
        ("--or"
         (push (pop argv) or-tags))
        ((guard (string-match-p "^--lang=" arg))
         (setq lang (cadr (split-string arg "=" t t))))
        ((guard (file-directory-p arg))
         (setq srcs
               (append (directory-files-recursively arg "\\.org$")
                       srcs)))
        ((guard (file-exists-p arg))
         (push arg srcs))
        (_ (error "Unknown option or file: %s" arg)))))

  (dolist (file srcs)
    (message (format "\n\nNow tangling %s:\n" file))
    (let ((backup (make-temp-file (file-name-base file) nil ".backup.org")))
      (unwind-protect
          ;; Prevent slow hooks from interfering
          (let (org-mode-hook)
            ;; We do the ol' switcheroo because `org-babel-tangle' writes
            ;; changes to the current file, which would be imposing on the user.
            (copy-file file backup t)
            (with-current-buffer (find-file-noselect file)

              ;; Tangling doesn't expand #+INCLUDE directives, so we do it
              ;; ourselves, since includes are so useful for literate configs!
              ;; (org-export-expand-include-keyword)

              (org-babel-tangle nil nil lang)))
        (ignore-errors (copy-file backup file t))
        (ignore-errors (delete-file backup)))))
  (kill-emacs 0))
#+end_src

* org-tangle-functions.el

#+call: hash() :exports none

#+RESULTS:
: 20210601225401786848500

#+name: 20210601225401786848500
#+begin_src emacs-lisp :tangle (meq/tangle-path)
(when (file-exists-p "~/.emacs.d/README.org")
    (org-babel-lob-ingest "~/.emacs.d/README.org"))
(when (file-exists-p "~/.emacs.d/strange.aiern.org")
    (org-babel-lob-ingest "~/.emacs.d/strange.aiern.org"))

(defun meq/get-header nil (interactive)
    (nth 4 (org-heading-components)))
(defun meq/tangle-path nil (interactive)
    (string-remove-prefix "/" (concat
        (org-format-outline-path (org-get-outline-path)) "/"
            (meq/get-header))))
(defun meq/get-theme-from-header nil (interactive)
    (string-remove-suffix "-theme.el" (meq/get-header)))
#+end_src

* git-subtree

#+begin_src bash :tangle (meq/tangle-path) :shebang "#!/usr/bin/env bash"
#
# git-subtree.sh: split/join git repositories in subdirectories of this one
#
# Copyright (C) 2009 Avery Pennarun <apenwarr@gmail.com>
#
if [ $# -eq 0 ]; then
    set -- -h
fi
OPTS_SPEC="\
git subtree add   --prefix=<prefix> <repository> <refspec>
git subtree merge --prefix=<prefix> <commit>
git subtree pull  --prefix=<prefix> [<repository> [<refspec>...]]
git subtree pull-all
git subtree push-all
git subtree push  --prefix=<prefix> [<repository> [<refspec>...]]
git subtree list
git subtree split --prefix=<prefix> <commit...>
git subtree from-submodule --prefix=<prefix>
git subtree prune
git subtree diff  --prefix=<prefix> [<repository> [<refspec>...]]
--
h,help        show the help
q             quiet
d             show debug messages
P,prefix=     the name of the subdir to split out
m,message=    use the given message as the commit message for the merge commit
 options for 'split'
annotate=     add a prefix to commit message of new commits
b,branch=     create a new branch from the split subtree
ignore-joins  ignore prior --rejoin commits
onto=         try connecting new tree to an existing one
rejoin        merge the new branch back into HEAD
 options for 'push'
f,force       use force push
 options for 'add', 'merge', 'pull' and 'push'
squash        merge subtree changes as a single commit
"
eval "$(echo "$OPTS_SPEC" | git rev-parse --parseopt -- "$@" || echo exit $?)"

PATH=$PATH:$(git --exec-path)
. git-sh-setup

require_work_tree

quiet=
branch=
debug=
command=
onto=
rejoin=
ignore_joins=
annotate=
squash=
message=

debug()
{
        if [ -n "$debug" ]; then
                echo "$@" >&2
        fi
}

say()
{
        if [ -z "$quiet" ]; then
                echo "$@" >&2
        fi
}

assert()
{
        if "$@"; then
                :
        else
                die "assertion failed: " "$@"
        fi
}


#echo "Options: $*"

while [ $# -gt 0 ]; do
        opt="$1"
        shift
        case "$opt" in
                -q) quiet=1 ;;
                -d) debug=1 ;;
                --annotate) annotate="$1"; shift ;;
                --no-annotate) annotate= ;;
                -b) branch="$1"; shift ;;
                -P|--prefix) prefix="$1"; shift ;;
                -m) message="$1"; shift ;;
                -f|--force) force=1 ;;
                --no-prefix) prefix= ;;
                --onto) onto="$1"; shift ;;
                --no-onto) onto= ;;
                --rejoin) rejoin=1 ;;
                --no-rejoin) rejoin= ;;
                --ignore-joins) ignore_joins=1 ;;
                --no-ignore-joins) ignore_joins= ;;
                --squash) squash=1 ;;
                --no-squash) squash= ;;
                --) break ;;
                *) die "Unexpected option: $opt" ;;
        esac
done

# Remove trailing slash
prefix="${prefix%/}";

command="$1"
shift
case "$command" in
        add|merge|pull|pull-all|push-all|from-submodule|prune) default= ;;
        split|push|diff|list) default="--default HEAD" ;;
        *) die "Unknown command '$command'" ;;
esac

if [ -z "$prefix" -a "$command" != "pull-all" -a "$command" != "push-all" -a "$command" != "list" -a "$command" != "prune" ]; then
        die "You must provide the --prefix option."
fi

case "$command" in
        pull-all);;
        push-all);;
        list);;
        prune);;
        add) [ -e "$prefix" ] && 
                die "prefix '$prefix' already exists." ;;
        *)   [ -e "$prefix" ] || 
                die "'$prefix' does not exist; use 'git subtree add'" ;;
esac

dir="$(dirname "$prefix/.")"

if [ "$command" != "pull" -a "$command" != "add" -a "$command" != "push" -a "$command" != "pull-all" -a "$command" != "diff" ]; then
        revs=$(git rev-parse $default --revs-only "$@") || exit $?
        dirs="$(git rev-parse --no-revs --no-flags "$@")" || exit $?
        if [ -n "$dirs" ]; then
                die "Error: Use --prefix instead of bare filenames."
        fi
fi

debug "command: {$command}"
debug "quiet: {$quiet}"
debug "revs: {$revs}"
debug "dir: {$dir}"
debug "opts: {$*}"
debug

cache_setup()
{
        cachedir="$GIT_DIR/subtree-cache/$$"
        rm -rf "$cachedir" || die "Can't delete old cachedir: $cachedir"
        mkdir -p "$cachedir" || die "Can't create new cachedir: $cachedir"
        mkdir -p "$cachedir/notree" || die "Can't create new cachedir: $cachedir/notree"
        debug "Using cachedir: $cachedir" >&2
}

cache_get()
{
        for oldrev in $*; do
                if [ -r "$cachedir/$oldrev" ]; then
                        read newrev <"$cachedir/$oldrev"
                        echo $newrev
                fi
        done
}

cache_miss()
{
        for oldrev in $*; do
                if [ ! -r "$cachedir/$oldrev" ]; then
                        echo $oldrev
                fi
        done
}

check_parents()
{
        missed=$(cache_miss $*)
        for miss in $missed; do
                if [ ! -r "$cachedir/notree/$miss" ]; then
                        debug "  incorrect order: $miss"
                fi
        done
}

set_notree()
{
        echo "1" > "$cachedir/notree/$1"
}

cache_set()
{
        oldrev="$1"
        newrev="$2"
        if [ "$oldrev" != "latest_old" \
             -a "$oldrev" != "latest_new" \
             -a -e "$cachedir/$oldrev" ]; then
                die "cache for $oldrev already exists!"
        fi
        echo "$newrev" >"$cachedir/$oldrev"
}

rev_exists()
{
        if git rev-parse "$1" >/dev/null 2>&1; then
                return 0
        else
                return 1
        fi
}

rev_is_descendant_of_branch()
{
        newrev="$1"
        branch="$2"
        branch_hash=$(git rev-parse $branch)
        match=$(git rev-list -1 $branch_hash ^$newrev)

        if [ -z "$match" ]; then
                return 0
        else
                return 1
        fi
}

# if a commit doesn't have a parent, this might not work.  But we only want
# to remove the parent from the rev-list, and since it doesn't exist, it won't
# be there anyway, so do nothing in that case.
try_remove_previous()
{
        if rev_exists "$1^"; then
                echo "^$1^"
        fi
}

find_latest_squash()
{
        debug "Looking for latest squash ($dir)..."
        dir="$1"
        sq=
        main=
        sub=
        git log --grep="^git-subtree-dir: $dir/*\$" \
                --pretty=format:'START %H%n%s%n%n%b%nEND%n' HEAD |
        while read a b junk; do
                debug "$a $b $junk"
                debug "{{$sq/$main/$sub}}"
                case "$a" in
                        START) sq="$b" ;;
                        git-subtree-mainline:) main="$b" ;;
                        git-subtree-split:) sub="$b" ;;
                        END)
                                if [ -n "$sub" ]; then
                                        if [ -n "$main" ]; then
                                                # a rejoin commit?
                                                # Pretend its sub was a squash.
                                                sq="$sub"
                                        fi
                                        debug "Squash found: $sq $sub"
                                        echo "$sq" "$sub"
                                        break
                                fi
                                sq=
                                main=
                                sub=
                                ;;
                esac
        done
}

find_existing_splits()
{
        debug "Looking for prior splits..."
        dir="$1"
        revs="$2"
        main=
        sub=
        git log --grep="^git-subtree-dir: $dir/*\$" \
                --pretty=format:'START %H%n%s%n%n%b%nEND%n' $revs |
        while read a b junk; do
                case "$a" in
                        START) sq="$b" ;;
                        git-subtree-mainline:) main="$b" ;;
                        git-subtree-split:) sub="$b" ;;
                        END)
                                debug "  Main is: '$main'"
                                if [ -z "$main" -a -n "$sub" ]; then
                                        # squash commits refer to a subtree
                                        debug "  Squash: $sq from $sub"
                                        cache_set "$sq" "$sub"
                                fi
                                if [ -n "$main" -a -n "$sub" ]; then
                                        debug "  Prior: $main -> $sub"
                                        cache_set $main $sub
                                        cache_set $sub $sub
                                        try_remove_previous "$main"
                                        try_remove_previous "$sub"
                                fi
                                main=
                                sub=
                                ;;
                esac
        done
}

copy_commit()
{
        # We're going to set some environment vars here, so
        # do it in a subshell to get rid of them safely later
        debug copy_commit "{$1}" "{$2}" "{$3}"
        git log -1 --pretty=format:'%an%n%ae%n%ad%n%cn%n%ce%n%cd%n%s%n%n%b' "$1" |
        (
                read GIT_AUTHOR_NAME
                read GIT_AUTHOR_EMAIL
                read GIT_AUTHOR_DATE
                read GIT_COMMITTER_NAME
                read GIT_COMMITTER_EMAIL
                read GIT_COMMITTER_DATE
                export  GIT_AUTHOR_NAME \
                        GIT_AUTHOR_EMAIL \
                        GIT_AUTHOR_DATE \
                        GIT_COMMITTER_NAME \
                        GIT_COMMITTER_EMAIL \
                        GIT_COMMITTER_DATE
                (echo -n "$annotate"; cat ) |
                git commit-tree "$2" $3  # reads the rest of stdin
        ) || die "Can't copy commit $1"
}

add_msg()
{
        dir="$1"
        latest_old="$2"
        latest_new="$3"
        if [ -n "$message" ]; then
                commit_message="$message"
        else
                commit_message="Add '$dir/' from commit '$latest_new'"
        fi
        cat <<-EOF
				$commit_message

				git-subtree-dir: $dir
				git-subtree-mainline: $latest_old
				git-subtree-split: $latest_new
		EOF
}

add_squashed_msg()
{
        if [ -n "$message" ]; then
                echo "$message"
        else
                echo "Merge commit '$1' as '$2'"
        fi
}

rejoin_msg()
{
        dir="$1"
        latest_old="$2"
        latest_new="$3"
        if [ -n "$message" ]; then
                commit_message="$message"
        else
                commit_message="Split '$dir/' into commit '$latest_new'"
        fi
        cat <<-EOF
                $commit_message
                
                git-subtree-dir: $dir
                git-subtree-mainline: $latest_old
                git-subtree-split: $latest_new
		EOF
}

squash_msg()
{
        dir="$1"
        oldsub="$2"
        newsub="$3"
        newsub_short=$(git rev-parse --short "$newsub")
        
        if [ -n "$oldsub" ]; then
                oldsub_short=$(git rev-parse --short "$oldsub")
                echo "Squashed '$dir/' changes from $oldsub_short..$newsub_short"
                echo
                git log --pretty=tformat:'%h %s' "$oldsub..$newsub"
                git log --pretty=tformat:'REVERT: %h %s' "$newsub..$oldsub"
        else
                echo "Squashed '$dir/' content from commit $newsub_short"
        fi
        
        echo
        echo "git-subtree-dir: $dir"
        echo "git-subtree-split: $newsub"
}

toptree_for_commit()
{
        commit="$1"
        git log -1 --pretty=format:'%T' "$commit" -- || exit $?
}

subtree_for_commit()
{
        commit="$1"
        dir="$2"
        git ls-tree "$commit" -- "$dir" |
        while read mode type tree name; do
                assert [ "$name" = "$dir" ]
                assert [ "$type" = "tree" -o "$type" = "commit" ]
                [ "$type" = "commit" ] && continue  # ignore submodules
                echo $tree
                break
        done
}

tree_changed()
{
        tree=$1
        shift
        if [ $# -ne 1 ]; then
                return 0   # weird parents, consider it changed
        else
                ptree=$(toptree_for_commit $1)
                if [ "$ptree" != "$tree" ]; then
                        return 0   # changed
                else
                        return 1   # not changed
                fi
        fi
}

new_squash_commit()
{
        old="$1"
        oldsub="$2"
        newsub="$3"
        tree=$(toptree_for_commit $newsub) || exit $?
        if [ -n "$old" ]; then
                squash_msg "$dir" "$oldsub" "$newsub" | 
                        git commit-tree "$tree" -p "$old" || exit $?
        else
                squash_msg "$dir" "" "$newsub" |
                        git commit-tree "$tree" || exit $?
        fi
}

copy_or_skip()
{
        rev="$1"
        tree="$2"
        newparents="$3"
        assert [ -n "$tree" ]

        identical=
        nonidentical=
        p=
        gotparents=
        for parent in $newparents; do
                ptree=$(toptree_for_commit $parent) || exit $?
                [ -z "$ptree" ] && continue
                if [ "$ptree" = "$tree" ]; then
                        # an identical parent could be used in place of this rev.
                        identical="$parent"
                else
                        nonidentical="$parent"
                fi
                
                # sometimes both old parents map to the same newparent;
                # eliminate duplicates
                is_new=1
                for gp in $gotparents; do
                        if [ "$gp" = "$parent" ]; then
                                is_new=
                                break
                        fi
                done
                if [ -n "$is_new" ]; then
                        gotparents="$gotparents $parent"
                        p="$p -p $parent"
                fi
        done
        
        if [ -n "$identical" ]; then
                echo $identical
        else
                copy_commit $rev $tree "$p" || exit $?
        fi
}

ensure_clean()
{
        if ! git diff-index HEAD --exit-code --quiet 2>&1; then
                die "Working tree has modifications.  Cannot add."
        fi
        if ! git diff-index --cached HEAD --exit-code --quiet 2>&1; then
                die "Index has modifications.  Cannot add."
        fi
}

cmd_add()
{
        if [ -e "$dir" ]; then
                die "'$dir' already exists.  Cannot add."
        fi

        ensure_clean
        
        if [ $# -eq 1 ]; then
                "cmd_add_commit" "$@"
        elif [ $# -eq 2 ]; then
                "cmd_add_repository" "$@"
        else
            say "error: parameters were '$@'"
            die "Provide either a refspec or a repository and refspec."
        fi
}

cmd_add_repository()
{
        echo "git fetch" "$@"
        repository=$1
        refspec=$2
        git fetch "$@" || exit $?
        revs=FETCH_HEAD
        set -- $revs
        cmd_add_commit "$@"

        # now add it to our list of repos
        git config -f .gittrees --unset subtree.$dir.url
        git config -f .gittrees --add subtree.$dir.url $repository
        git config -f .gittrees --unset subtree.$dir.path
        git config -f .gittrees --add subtree.$dir.path $dir
        git config -f .gittrees --unset subtree.$dir.branch
        git config -f .gittrees --add subtree.$dir.branch $refspec
}

cmd_add_commit()
{
        revs=$(git rev-parse $default --revs-only "$@") || exit $?
        set -- $revs
        rev="$1"
        
        debug "Adding $dir as '$rev'..."
        git read-tree --prefix="$dir" $rev || exit $?
        git checkout -- "$dir" || exit $?
        tree=$(git write-tree) || exit $?
        
        headrev=$(git rev-parse HEAD) || exit $?
        if [ -n "$headrev" -a "$headrev" != "$rev" ]; then
                headp="-p $headrev"
        else
                headp=
        fi
        
        if [ -n "$squash" ]; then
                rev=$(new_squash_commit "" "" "$rev") || exit $?
                commit=$(add_squashed_msg "$rev" "$dir" |
                         git commit-tree $tree $headp -p "$rev") || exit $?
        else
                commit=$(add_msg "$dir" "$headrev" "$rev" |
                         git commit-tree $tree $headp -p "$rev") || exit $?
        fi
        git reset "$commit" || exit $?
        
        say "Added dir '$dir'"
}

cmd_split()
{
        debug "Splitting $dir..."
        cache_setup || exit $?
        
        if [ -n "$onto" ]; then
                debug "Reading history for --onto=$onto..."
                git rev-list $onto |
                while read rev; do
                        # the 'onto' history is already just the subdir, so
                        # any parent we find there can be used verbatim
                        debug "  cache: $rev"
                        cache_set $rev $rev
                done
        fi
        
        if [ -n "$ignore_joins" ]; then
                unrevs=
        else
                unrevs="$(find_existing_splits "$dir" "$revs")"
        fi
        
        # We can't restrict rev-list to only $dir here, because some of our
        # parents have the $dir contents the root, and those won't match.
        # (and rev-list --follow doesn't seem to solve this)
        grl='git rev-list --topo-order --reverse --parents $revs $unrevs'
        revmax=$(eval "$grl" | wc -l)
        revcount=0
        createcount=0
        eval "$grl" |
        while read rev parents; do
                revcount=$(($revcount + 1))
                say -n "$revcount/$revmax ($createcount)
"
                debug "Processing commit: $rev"
                exists=$(cache_get $rev)
                if [ -n "$exists" ]; then
                        debug "  prior: $exists"
                        continue
                fi
                createcount=$(($createcount + 1))
                debug "  parents: $parents"
                newparents=$(cache_get $parents)
                debug "  newparents: $newparents"
                
                tree=$(subtree_for_commit $rev "$dir")
                debug "  tree is: $tree"

                check_parents $parents
                
                # ugly.  is there no better way to tell if this is a subtree
                # vs. a mainline commit?  Does it matter?
                if [ -z $tree ]; then
                        set_notree $rev
                        if [ -n "$newparents" ]; then
                                cache_set $rev $rev
                        fi
                        continue
                fi

                newrev=$(copy_or_skip "$rev" "$tree" "$newparents") || exit $?
                debug "  newrev is: $newrev"
                cache_set $rev $newrev
                cache_set latest_new $newrev
                cache_set latest_old $rev
        done || exit $?
        latest_new=$(cache_get latest_new)
        if [ -z "$latest_new" ]; then
                die "No new revisions were found"
        fi
        
        if [ -n "$rejoin" ]; then
                debug "Merging split branch into HEAD..."
                latest_old=$(cache_get latest_old)
                git merge -s ours \
                        -m "$(rejoin_msg $dir $latest_old $latest_new)" \
                        $latest_new >&2 || exit $?
        fi
        if [ -n "$branch" ]; then
                if rev_exists "refs/heads/$branch"; then
                        if ! rev_is_descendant_of_branch $latest_new $branch; then
                                die "Branch '$branch' is not an ancestor of commit '$latest_new'."
                        fi
                        action='Updated'
                else
                        action='Created'
                fi
                git update-ref -m 'subtree split' "refs/heads/$branch" $latest_new || exit $?
                say "$action branch '$branch'"
        fi
        echo $latest_new
        exit 0
}

cmd_merge()
{
        revs=$(git rev-parse $default --revs-only "$@") || exit $?
        ensure_clean
        
        set -- $revs
        if [ $# -ne 1 ]; then
                die "You must provide exactly one revision.  Got: '$revs'"
        fi
        rev="$1"
        
        if [ -n "$squash" ]; then
                first_split="$(find_latest_squash "$dir")"
                if [ -z "$first_split" ]; then
                        die "Can't squash-merge: '$dir' was never added."
                fi
                set $first_split
                old=$1
                sub=$2
                if [ "$sub" = "$rev" ]; then
                        say "Subtree is already at commit $rev."
                        exit 0
                fi
                new=$(new_squash_commit "$old" "$sub" "$rev") || exit $?
                debug "New squash commit: $new"
                rev="$new"
        fi

        version=$(git version)
        if [ "$version" \< "git version 1.7" ]; then
                if [ -n "$message" ]; then
                        git merge -s subtree --message="$message" $rev
                else
                        git merge -s subtree $rev
                fi
        else
                if [ -n "$message" ]; then
                        git merge -Xsubtree="$prefix" --message="$message" $rev
                else
                        git merge -Xsubtree="$prefix" $rev
                fi
        fi
}

cmd_pull()
{
        if [ $# -gt 2 ]; then
                die "You should provide either <refspec> or <repository> <refspec>"
        fi
        if [ -e "$dir" ]; then
                ensure_clean
                if [ $# -eq 1 ]; then
                        repository=$(git config -f .gittrees subtree.$prefix.url)
                        refspec=$1
                elif [ $# -eq 2 ]; then
                        repository=$1
                        refspec=$2
                else
                        repository=$(git config -f .gittrees subtree.$prefix.url)
                        refspec=$(git config -f .gittrees subtree.$prefix.branch)
                fi
                git fetch $repository $refspec || exit $?
                echo "git fetch using: " $repository $refspec
                revs=FETCH_HEAD
                set -- $revs
                cmd_merge "$@"
        else
                die "'$dir' must already exist. Try 'git subtree add'."
        fi
}

cmd_diff()
{
        if [ -e "$dir" ]; then
                if [ $# -eq 1 ]; then
                        repository=$(git config -f .gittrees subtree.$prefix.url)
                        refspec=$1
                elif [ $# -eq 2 ]; then
                        repository=$1
                        refspec=$2
                else
                        repository=$(git config -f .gittrees subtree.$prefix.url)
                        refspec=$(git config -f .gittrees subtree.$prefix.branch)
                fi
                # this is ugly, but I don't know of a better way to do it. My git-fu is weak.
                # git diff-tree expects a treeish, but I have only a repository and branch name.
                # I don't know how to turn that into a treeish without creating a remote.
                # Please change this if you know a better way!
                tmp_remote=__diff-tmp
                git remote rm $tmp_remote > /dev/null 2>&1
                git remote add -t $refspec $tmp_remote $repository > /dev/null
                # we fetch as a separate step so we can pass -q (quiet), which isn't an option for "git remote"
                # could this instead be "git fetch -q $repository $refspec" and leave aside creating the remote?
                # Still need a treeish for the diff-tree command...
                git fetch -q $tmp_remote
                git diff-tree -p refs/remotes/$tmp_remote/$refspec
                git remote rm $tmp_remote > /dev/null 2>&1
        else
                die "Cannot resolve directory '$dir'. Please point to an existing subtree directory to diff. Try 'git subtree add' to add a subtree."
        fi
}
cmd_push()
{
        if [ $# -gt 2 ]; then
                die "You shold provide either <refspec> or <repository> <refspec>"
        fi
        if [ -e "$dir" ]; then
                if [ $# -eq 1 ]; then
                        repository=$(git config -f .gittrees subtree.$prefix.url)
                        refspec=$1
                elif [ $# -eq 2 ]; then
                        repository=$1
                        refspec=$2
                else
                        repository=$(git config -f .gittrees subtree.$prefix.url)
                        refspec=$(git config -f .gittrees subtree.$prefix.branch)
                fi

                push_opts=
                if [ "$force" == "1" ]; then
                  push_opts="$push_opts --force"
                fi

                echo "git push using: " $repository $refspec
                rev=$(git subtree split --prefix=$prefix)
                if [ -n "$rev" ]; then
                        git push $push_opts $repository $rev:refs/heads/$refspec
                else
                        die "Couldn't push, 'git subtree split' failed."
                fi
        else
            die "'$dir' must already exist. Try 'git subtree add'."
        fi
}

subtree_list()
{
        git config -f .gittrees -l | grep subtree | grep path | sed "s/.*=//g" |
        while read path; do
                repository=$(git config -f .gittrees subtree.$path.url)
                refspec=$(git config -f .gittrees subtree.$path.branch)
                echo "  $path           (merged from $repository branch $refspec) "
        done
}

cmd_list()
{
  subtree_list
}

cmd_from-submodule()
{
        ensure_clean

        local submodule_sha=$(git submodule status $prefix | cut -d ' ' -f 2)
        local submodule_orig_repo=$(git config --file .gitmodules submodule.$prefix.url)

        # Remove references to submodule.
        git config --remove-section submodule.$prefix
        git config --file .gitmodules --remove-section submodule.$prefix
        git add .gitmodules

        # Move submodule aside.
        local tmp_repo="$(mktemp -d /tmp/git-subtree.XXXXX)"
        rm -r $tmp_repo
        mv $prefix $tmp_repo
        git rm $prefix

        # Commit changes.
        git commit -m "Remove '$prefix/' submodule"

        # subtree add from submodule repo.
        # TODO: Could be determin HEAD to be a specific branch
        cmd_add_repository $tmp_repo HEAD

        # Update .gittrees with the original repo url
        git config --file .gittrees --unset subtree.$prefix.url
        git config --file .gittrees subtree.$prefix.url $submodule_orig_repo

        # Remove submodule repo.
        rm -rf $tmp_repo
}

cmd_prune()
{
        git config -f .gittrees -l | grep subtree | grep path | sed "s/.*=//g" |
        while read path; do
                if [ ! -e "$path" ]; then
                        echo "pruning $path"
                        git config -f .gittrees --remove-section subtree.$path
                fi
        done
}

cmd_pull-all()
{
        git config -f .gittrees -l | grep subtree | grep path | sed "s/.*=//g" |
        while read path; do
                git subtree pull -P $path $(git config -f .gittrees subtree.$path.url) $(git config -f .gittrees subtree.$path.branch) || exit $?
        done
}

cmd_push-all()
{
        git config -f .gittrees -l | grep subtree | grep path | sed "s/.*=//g" |
        while read path; do
                git subtree push -P $path $(git config -f .gittrees subtree.$path.url) $(git config -f .gittrees subtree.$path.branch) || exit $?
        done
}

"cmd_$command" "$@"
#+end_src

* .gitconfig

#+begin_src conf :tangle (meq/tangle-path)
[remote "aiern"]
    url = git@github.com:shadowrylander/aiern
    fetch = +refs/heads/*:refs/remotes/aiern/*
[remote "doom-aiern-modeline"]
    url = git@github.com:shadowrylander/doom-aiern-modeline
    fetch = +refs/heads/*:refs/remotes/doom-aiern-modeline/*
[remote "alloy"]
    url = git@github.com:shadowrylander/alloy.git
    fetch = +refs/heads/*:refs/remotes/alloy/*
[remote "alamode"]
    url = git@github.com:shadowrylander/alamode
    fetch = +refs/heads/*:refs/remotes/alamode/*
[remote "use-package-extras"]
    url = git@github.com:shadowrylander/use-package-extras
    fetch = +refs/heads/*:refs/remotes/use-package-extras/*
[remote "deino"]
    url = git@github.com:shadowrylander/deino
    fetch = +refs/heads/*:refs/remotes/deino/*
[remote "use-package-deino"]
    url = git@github.com:shadowrylander/use-package-deino
    fetch = +refs/heads/*:refs/remotes/use-package-deino/*
[remote "sorrow"]
    url = git@github.com:shadowrylander/sorrow
    fetch = +refs/heads/*:refs/remotes/sorrow/*
[remote "lode"]
    url = git@github.com:shadowrylander/lode
    fetch = +refs/heads/*:refs/remotes/lode/*
[remote "meq"]
    url = git@github.com:shadowrylander/meq.git
    fetch = +refs/heads/*:refs/remotes/meq/*
[remote "aiern-god-state"]
    url = git@github.com:shadowrylander/aiern-god-state
    fetch = +refs/heads/*:refs/remotes/aiern-god-state/*
[remote "janus"]
    url = git@github.com:shadowrylander/janus
    fetch = +refs/heads/*:refs/remotes/janus/*
[remote "titan"]
    url = git@github.com:shadowrylander/titan
    fetch = +refs/heads/*:refs/remotes/titan/*
[remote "fell"]
    url = git@github.com:shadowrylander/fell
    fetch = +refs/heads/*:refs/remotes/fell/*
[remote "doc"]
    url = git@github.com:shadowrylander/doc
    fetch = +refs/heads/*:refs/remotes/doc/*
[remote "cosmoem"]
    url = git@gitlab.com:shadowrylander/cosmoem
    fetch = +refs/heads/*:refs/remotes/cosmoem/*
[remote "cosmog"]
    url = git@github.com:shadowrylander/cosmog
    fetch = +refs/heads/*:refs/remotes/cosmog/*
[remote "prime"]
    url = git@github.com:shadowrylander/prime
    fetch = +refs/heads/*:refs/remotes/prime/*
[remote "uru"]
    url = git@github.com:shadowrylander/uru
    fetch = +refs/heads/*:refs/remotes/uru/*
[remote "meta"]
    url = git@github.com:shadowrylander/meta
    fetch = +refs/heads/*:refs/remotes/meta/*
[remote "riot"]
    url = git@github.com:shadowrylander/riot
    fetch = +refs/heads/*:refs/remotes/riot/*
[remote "evil-evilified-state"]
    url = git@github.com:shadowrylander/evil-evilified-state
    fetch = +refs/heads/*:refs/remotes/evil-evilified-state/*
[remote "helm-ido-like-guide"]
    url = git@github.com:shadowrylander/helm-ido-like-guide
    fetch = +refs/heads/*:refs/remotes/helm-ido-like-guide/*
#+end_src

* makefile

#+call: hash() :exports none

#+RESULTS:
: 20210622004216528168500

#+name: 20210622004216528168500
#+begin_src makefile :tangle (meq/tangle-path)
# Adapted From: https://www.systutorials.com/how-to-get-the-full-path-and-directory-of-a-makefile-itself/
.RECIPEPREFIX := |
.DEFAULT_GOAL := emacs

mkfilePath := $(abspath $(lastword $(MAKEFILE_LIST)))
mkfileDir := $(dir $(mkfilePath))
test := emacs -nw --bg-daemon=test
killTest := emacsclient -s test -e "(kill-emacs)"

init:
|-sudo cp $(mkfileDir)/git-subtree $$(git --exec-path)/

subinit:
|git -C $(mkfileDir) submodule update --init --depth 1 --force
|git -C $(mkfileDir) submodule sync
# |git -C $(mkfileDir) submodule foreach 'git -C $$toplevel config submodule.$$name.ignore all'
|cd $(mkfileDir)/lib/org; make; make autoloads

pull: init
|git -C $(mkfileDir) pull
|git -C $(mkfileDir) subtree pull-all

add:
|git submodule foreach git stash
|git -C $(mkfileDir) add .

commit:
|-git -C $(mkfileDir) commit --allow-empty-message -am ""

cammit: add commit

push-only: add commit
|-git -C $(mkfileDir) push

push: push-only init
|git -C $(mkfileDir) subtree prune
|-git -C $(mkfileDir) subtree push-all

tangle-setup:
|cp $(mkfileDir)/org-tangle.sh $(mkfileDir)/backup-tangle.sh
|chmod +x $(mkfileDir)/org-tangle.sh $(mkfileDir)/backup-tangle.sh

tangle: tangle-setup
|yes yes | fd . $(mkfileDir) \
    -HIe org \
    -E testing.aiern.org \
    -E resting.aiern.org \
    -E profiles \
    -E lib \
    -x $(mkfileDir)/backup-tangle.sh
|yes yes | fd . $(mkfileDir)/profiles/damascus \
    -HIe org \
    -E .local \
    -x $(mkfileDir)/backup-tangle.sh
|yes yes | fd . $(mkfileDir)/profiles/graphene \
    -HIe org \
    -E .local \
    -x $(mkfileDir)/backup-tangle.sh
|yes yes | fd . $(mkfileDir)/profiles/nano \
    -HIe org \
    -E .local \
    -x $(mkfileDir)/backup-tangle.sh
|fd . $(mkfileDir) \
    -HIe sh \
    -E .local \
    -x chmod +x

subtree-prep: tangle push-only

test:
|emacs -nw

test-doom:
|emacs -nw --doom

test-graphene:
|emacs -nw --graphene

test-nano:
|emacs -nw --nano

pest:
|emacs -nw -p

test-and-kill-pre:
|-emacsclient -s test -e "(kill-emacs)"

test-and-kill: test-and-kill-pre
|$(test)
|$(killTest)

test-new-and-kill: test-and-kill-pre
|$(test) -Q
|$(killTest)

test-update-and-kill: test-and-kill-pre
|$(test) --update
|$(killTest)

test-update-doom-and-kill: test-and-kill-pre
|$(test) --udoom
|$(killTest)

test-update-graphene-and-kill: test-and-kill-pre
|$(test) --graphene --update
|$(killTest)

test-update-nano-and-kill: test-and-kill-pre
|$(test) --nano --update
|$(killTest)

delete-doom:
|rm -rf $(mkfileDir)/profiles/doom/.local

delete:
|rm -rf $(mkfileDir)/profiles/damascus/.local

delete-graphene:
|rm -rf $(mkfileDir)/profiles/graphene/.local

delete-nano:
|rm -rf $(mkfileDir)/profiles/nano/.local

update-test:
|emacs -nw --update

no-config-test:
|emacs -nw -Q

emacs: tangle test
remacs: delete tangle test-update-and-kill test
doom-remacs: delete-doom tangle test-update-doom-and-kill test-doom
graphene-remacs: delete-graphene tangle test-update-graphene-and-kill test-graphene
nano-remacs: delete-nano tangle test-update-nano-and-kill test-nano
super-push: tangle push
super-push-only: tangle push-only
#+end_src

* lib
** damascus.el

#+call: hash() :exports none

#+RESULTS:
: 20210616175359970389700

#+name: 20210616175359970389700
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; damascus.el --- a simple package                     -*- lexical-binding: t; -*-

;; Copyright (C) 2021  Jeet Ray

;; Author: Jeet Ray <aiern@protonmail.com>
;; Keywords: lisp
;; Version: 0.0.1

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; Put a description of the package here

;;; Code:

;; code goes here

(provide 'damascus)
;;; damascus.el ends here
#+end_src

** meq-exwm-config.el

#+call: hash() :exports none

#+RESULTS:
: 20210821192734044989400

#+name: 20210821192734044989400
#+begin_src emacs-lisp :tangle (meq/tangle-path) :exports none
(meq/up exwm
    :init/defun* (post-exwm nil (interactive)
                    (unless (get-buffer "Alacritty") (meq/run "alacritty"))
                    (unless (get-buffer "obsidian") (meq/run "obsidian")))
    :hook (exwm-init . post-exwm)
    :use-package-postconfig (dmenu)
    :config
        (require 'scroll-bar)
        ;; Adapted From: https://github.com/ch11ng/exwm/blob/master/exwm-config.el#L34
        (require 'exwm-config)
        ;; Set the initial workspace number.
        (unless (get 'exwm-workspace-number 'saved-value)
            (setq exwm-workspace-number 4))
        ;; Make class name the buffer name
        (add-hook 'exwm-update-class-hook
                    (lambda ()
                    (exwm-workspace-rename-buffer exwm-class-name)))
        ;; Global keybindings.
        (unless (get 'exwm-input-global-keys 'saved-value)
            (setq exwm-input-global-keys
                `(
                    ;; 's-{p|`|z}': Enter the exwm-global deino
                    ([?\s-p] . uru)
                    ([?\s-`] . uru)
                    ([?\s-z] . uru)

                    ([?\s-q] . (lambda nil (interactive)
                        (unless meq/var/everything-else-initialized (meq/initialize-everything-else))
                        (deino-buffer/body)))

                    ;; 's-N': Switch to certain workspace.
                    ,@(mapcar (lambda (i)
                                `(,(kbd (format "s-%d" i)) .
                                (lambda ()
                                    (interactive)
                                    (exwm-workspace-switch-create ,i))))
                            (number-sequence 0 9)))))
        ;; Line-editing shortcuts
        (unless (get 'exwm-input-simulation-keys 'saved-value)
            (setq exwm-input-simulation-keys
                '(([?\C-b] . [left])
                    ([?\C-f] . [right])
                    ([?\C-p] . [up])
                    ([?\C-n] . [down])
                    ([?\C-a] . [home])
                    ([?\C-e] . [end])
                    ([?\M-v] . [prior])
                    ([?\C-v] . [next])
                    ([?\C-d] . [delete])
                    ([?\C-k] . [S-end delete]))))
        ;; Enable EXWM
        (exwm-enable)
        ;; Configure Ido
        (exwm-config-ido)
        ;; Other configurations
        (exwm-config-misc)

        ;; (exwm-config-default)
        ;; (exwm-enable)

    ;; Adapted From: https://www.reddit.com/r/emacs/comments/8yf6dx/key_chords_in_exwm/
    :gsetq (exwm-manage-force-tiling t)
        ;; (exwm-input-line-mode-passthrough t)

    :demon ((naked "XF86PowerOff") 'deino-exwm/body)
    :which-key-change-ryo ("e" "exwm")
    :deino (deino-exwm nil "e e"
                ("`" nil "cancel")
                ("XF86PowerOff" deino-exwm/power/body "power")
                ("s" deino-exwm/shells/body "shells"))
            (deino-exwm/power (:color blue) "e p"
                ("r" (meq/run "reboot") "reboot")
                ("q" (meq/run "poweroff") "poweroff")
                ("XF86PowerOff" (meq/run "systemctl suspend" "suspend") "suspend"))
            (deino-exwm/shells (:color blue) "e s"
                ("a" (meq/run "alacritty") "alacritty"))
    :uru (exwm-mode deino-exwm-global (:color blue) "e g"
        ("`" nil "cancel")
        ("c" exwm-input-release-keyboard "char mode")
        ("l" exwm-input-grab-keyboard "line mode")
        ("r" exwm-reset "reset")
        ("w" exwm-workspace-switch "workspace switch")
        ("i" meq/run-interactive "run")
        ("b" deino-buffer/body "buffers")))
#+end_src

** meq-hydra-config.el

#+call: hash() :exports none

#+RESULTS:
: 20210821211206922820400

#+name: 20210821211206922820400
#+begin_src emacs-lisp :tangle (meq/tangle-path) :exports none
(meq/up hydra
    :custom (hydra-hint-display-type 'lv)
    :bind (:map hydra-base-map ("~" . hydra--universal-argument))
    :upnsd-preconfig (janus)
    :use-package-preconfig (use-package-hydra)
    :upnsd-postconfig (use-package-deino) (deino :custom (deino-hint-display-type 'lv)))
#+end_src

** meq-alloy-config.el

#+call: hash() :exports none

#+RESULTS:
: 20210821211654763595900

#+name: 20210821211654763595900
#+begin_src emacs-lisp :tangle (meq/tangle-path) :exports none
(meq/upnsd alloy
    :upnsd-postconfig (lode) (prime)
        (uru :config (prime "u u" uru "uru")
                    (prime "u m" minoru "minoru"))
    :use-package-preconfig (command-log-mode)
        ;; Important: https://github.com/noctuid/general.el/issues/53#issuecomment-307262154
        (use-package-chords)
    :config
        (alloy-auto-unbind-keys)
        (alloy-def :keymaps demon-run
            ;; Adapted From:
            ;; Answer: https://stackoverflow.com/a/4557027/10827766
            ;; User: https://stackoverflow.com/users/387076/gilles-so-stop-being-evil
            "\eOA" [up]
            "\e[A" [up]
            "\eOB" [down]
            "\e[B" [down]
            "\eOD" [left]
            "\e[D" [left]
            "\eOC" [right]
            "\e[C" [right]
            "M-x" 'meq/M-x)
    :deino (deino-restart (:color blue) "r"
            ("`" nil "cancel")
            ("l" meq/reload-emacs "reload")
            ("s" restart-emacs "restart"))
    :custom (alloy-implicit-naked t))
#+end_src

** meq-which-key-config.el

#+call: hash() :exports none

#+RESULTS:
: 20210821212520193609500

#+name: 20210821212520193609500
#+begin_src emacs-lisp :tangle (meq/tangle-path) :exports none
(meq/up which-key :deino (deino/which-key (:color blue :columns 4) "w"
        ("`" nil "cancel")
        ("a" cosmoem-any-popup-showing-p "any popup showing")
        ("h" meq/which-key--hide-popup "hide-popup")
        ("s" meq/which-key--show-popup "show-popup")
        ("r" meq/which-key--refresh-popup "refresh-popup")
        ("t" meq/toggle-which-key "toggle")
        ("l" meq/which-key-show-top-level "meq/toplevel")
        ("L" which-key-show-top-level "toplevel"))
    :gsetq
        (which-key-enable-extended-define-key t)
        (which-key-idle-delay 0.1)
        (which-key-idle-secondary-delay nil)
        (which-key-allow-evil-operators t)

        ;; NOTE: This will cause the which-key maps for the operator states to show up,
        ;; breaking functionality such as `d 13 <arrow-down>', etc.
        ;; (which-key-show-operator-state-maps t)

        ;; TODO: Choose a fun one!
        (which-key-separator " × ")
        ;; (which-key-separator " |-> ")

        (which-key-popup-type 'side-window)
        (which-key-side-window-location '(right bottom left top))

        ;; If this percentage is too small, the keybindings frame will appear at the bottom
        (which-key-side-window-max-width 0.5)

        (which-key-side-window-max-height 0.25))
#+end_src

** meq-cosmoem-config.el

#+call: hash() :exports none

#+RESULTS:
: 20210821211909575354500

#+name: 20210821211909575354500
#+begin_src emacs-lisp :tangle (meq/tangle-path) :exports none
(meq/upnsd cosmoem
    :upnsd-postconfig (meta)
    :config (prime ", m" map-of-infinity/body "map-of-infinity")
    :which-key-change-ryo ("," "damascus")
    :deino (map-of-infinity nil ", m"
            ("`" nil "cancel")
            ("w" deino/which-key/body "which-key")
            ("h" deino/cosmoem/body "cosmoem")
            ("d" meq/disable-all-modal-modes "disable all modal modes" :color blue)
            ("t" toggles/body "toggles")
            ("k" all-keymaps/body "all keymaps"))
        (deino/cosmoem (:color blue) ", c"
            ("`" nil "cancel")
            ("h" cosmoem-hide-all-modal-modes "hide all modal modes"))
        (toggles (:color blue) ", t" ("`" nil "cancel"))
        (all-keymaps (:color blue) ", k" ("`" nil "cancel")))
#+end_src

** meq-sorrow-config.el

#+call: hash() :exports none

#+RESULTS:
: 20210821211910346059700

#+name: 20210821211910346059700
#+begin_src emacs-lisp :tangle (meq/tangle-path) :exports none
(meq/upnsd sorrow
    :primer+ ("t" "toggles")
    :config ;; From: https://github.com/shadowrylander/sorrow#which-key-integration
        (push '((nil . "sorrow:.*:") . (nil . "")) which-key-replacement-alist))
#+end_src

* early-init.el

Adapted From: https://github.com/hlissner/doom-emacs/blob/develop/early-init.el

#+call: hash() :exports none

#+RESULTS:
: 20210604182053300746900

#+name: 20210604182053300746900
#+begin_src emacs-lisp :tangle (meq/tangle-path) :exports none
;;; $EMACSDIR/early-init.el -*- lexical-binding: t; -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Get rid of double dashes in scripts ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(when (string= (car (last command-line-args)) "--") (delete "--" command-line-args))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Define preliminary variables ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defvar meq/var/profiled t)
(defvar pre-user-emacs-directory (file-name-directory load-file-name))
(defvar meq/var/udei-profiles '(nano graphene))
(defvar meq/var/profile-name (if (member "--profile" command-line-args)
    (nth (1+ (seq-position command-line-args "--profile")) command-line-args) "damascus"))
(defvar meq/var/udei (or (member "--udei" command-line-args)
                            (member (intern meq/var/profile-name) meq/var/udei-profiles)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Delete command-line arguments already used
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(delete "--profile" command-line-args)
(delete meq/var/profile-name command-line-args)
(delete "--udei" command-line-args)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Adapted From: https://www.emacswiki.org/emacs/LoadPath#h5o-2 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; And: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Answer: https://emacs.stackexchange.com/a/55415/31428 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; User: https://emacs.stackexchange.com/users/14825/nickd ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(let ((default-directory (concat pre-user-emacs-directory "lib")))
    (add-to-list 'load-path (concat (file-name-directory load-file-name) "lib/org/lisp"))
    (require 'org-loaddefs)

    ;; To get the latest version of `org-mode', require the load-file before
    ;; byte-compilation of `lib'
    (byte-recompile-directory default-directory nil)
    
    (normal-top-level-add-to-load-path '("."))
    (normal-top-level-add-subdirs-to-load-path))
(let ((default-directory (concat pre-user-emacs-directory "siluam")))
    (byte-recompile-directory default-directory nil)
    (normal-top-level-add-to-load-path '("."))
    (normal-top-level-add-subdirs-to-load-path))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; We are `borg' ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(setq package-enable-at-startup nil)
(require 'borg)
(borg-initialize)
(setq borg-rewrite-urls-alist '(("git@github.com:" . "https://github.com/")
                                ("git@gitlab.com:" . "https://gitlab.com/")))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Set up `use-package' ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(with-no-warnings
  (setq use-package-verbose t)
  (setq use-package-enable-imenu-support t))
(require 'use-package)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Set up cleanup mechanisms ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(use-package no-littering :demand t)
(use-package gcmh :demand t :config (gcmh-mode 1))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Set up my `use-package-extras' ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(use-package use-package-extras
    :demand t
    :init (require 'a)
        (require 'dash)
        (require 's)
        (require 'f)
    :config
        (meq/up meq :load-emacs-file-preconfig ("naked"))
        (meq/up leaf :use-package-preconfig
            (use-package-ensure-system-package)
            (leaf-keywords)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Byte-compile the `damascus' profile if the `profile-name' is `damascus' or we need to
;;     use its `early-init'
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(when (or (string= meq/var/profile-name "damascus") meq/var/udei)
    (byte-recompile-directory (meq/ued* "profiles" "damascus") nil))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Set up the `user-emacs-directory' ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(setq user-emacs-directory (f-full (funcall #'meq/ued* "profiles" meq/var/profile-name)))
(unless (string= meq/var/profile-name "doom") (byte-recompile-directory user-emacs-directory nil))
(setq custom-file (funcall #'meq/ued "init.el"))
;; Adapted From:
;; Answer: https://emacs.stackexchange.com/a/18682/31428
;; User: https://emacs.stackexchange.com/users/2731/ebpa
(setq auto-save-list-file-prefix user-emacs-directory)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Implement `doom-emacs' updating ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(when (and
        (string= meq/var/profile-name "doom")
        (member "--update" command-line-args))
    (delete "--update" command-line-args)
    (call-process (meq/ued* "profiles" "doom" "bin" "doom") nil nil nil "update")
    (call-process (meq/ued* "profiles" "doom" "bin" "doom") nil nil nil "sync")
    (call-process (meq/ued* "profiles" "doom" "bin" "doom") nil nil nil "doctor"))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Use the damascus' early-init if nothing else is available or if preferred ;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(when meq/var/udei (meq/use-damascus-early-init) (add-to-list 'load-path (meq/ued "lisp")))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Set up theming ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(byte-recompile-directory (meq/ued* "themes") nil)
(add-to-list 'custom-theme-load-path (meq/ued* "themes"))
(setq custom-safe-themes t)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Load the profile's `early-init' if it exists ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(meq/cl "early-init.el")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src

* init.el

#+call: hash() :exports none

#+RESULTS:
: 20210804184605617540800

#+name: 20210804184605617540800
#+begin_src emacs-lisp :tangle (meq/tangle-path) :comments link
;;; $EMACSDIR/init.el -*- lexical-binding: t; -*-
(when (version< emacs-version "27") (load (concat (file-name-directory load-file-name) "early-init.el")))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Set up the `use-package' keywords for `exwm' ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(mapc #'(lambda (config) (interactive)
            (load (meq/ued-lib (concat "meq-" (symbol-name config) "-config"))))
    '(hydra alloy which-key cosmoem sorrow))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Set up `exwm' ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(load (meq/ued-lib "meq-exwm-config"))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(when meq/var/udei (meq/cl "lisp" (concat meq/var/profile-name ".el")))
(meq/cl "init.el")
#+end_src
